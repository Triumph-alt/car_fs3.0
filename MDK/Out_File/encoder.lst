C251 COMPILER V5.60.0,  encoder                                                            14/07/25  14:27:41  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE encoder
OBJECT MODULE PLACED IN .\Out_File\encoder.obj
COMPILER INVOKED BY: D:\Software\Keil5\c251v560\C251\BIN\C251.EXE ..\USER\src\encoder.c LARGE INTR2 WARNINGLEVEL(3) OPTI
                    -MIZE(0,SPEED) BROWSE INCDIR(..\USER\inc;..\USER\src;..\libraries;..\seekfree_libraries;..\seekfree_peripheral) DEBUG PRI
                    -NT(.\Out_File\encoder.lst) OBJECT(.\Out_File\encoder.obj) 

stmt  level    source

    1          #include "encoder.h"
    2          
    3          #define ENCODER_JUMP_THRESHOLD    20  // 编码器读数突变的阈值（略大于正常的最大值）
    4          #define MIN_STABILITY_COUNT       5   // 判定为稳定状态所需的最小连续计数
    5          #define COUNTER_SAFETY_RESET   10000  // 计数器防溢出重置值
    6          
    7          Encoder_t EncoderL, EncoderR;
    8          EncoderDebo_t EncoderDeboL, EncoderDeboR;
    9          
   10          void encoder_init(void)
   11          {
   12   1          EncoderL.encoder_original = 0;
   13   1          EncoderL.encoder_integral = 0;
   14   1          EncoderL.encoder_final = 0;
   15   1      
   16   1          EncoderR.encoder_integral = 0;
   17   1          EncoderR.encoder_original = 0;
   18   1          EncoderR.encoder_final = 0;
   19   1              
   20   1              EncoderDeboL.encoderlast = 0;
   21   1              EncoderDeboL.count = 0;
   22   1              
   23   1              EncoderDeboR.encoderlast = 0;
   24   1              EncoderDeboR.count = 0;
   25   1              
   26   1              ctimer_count_init(CTIM0_P34);
   27   1              ctimer_count_init(CTIM3_P04);
   28   1      }
   29          
   30          int get_left_encoder(void)
   31          {
   32   1              int encoder_left;
   33   1              
   34   1              if(LEFT_DIR == 1)
   35   1              {
   36   2                      encoder_left = ctimer_count_read(CTIM0_P34);
   37   2              }
   38   1              else
   39   1              {
   40   2                      encoder_left = ctimer_count_read(CTIM0_P34) * -1;
   41   2              }
   42   1              
   43   1              ctimer_count_clean(CTIM0_P34);
   44   1              
   45   1              return encoder_left;
   46   1      }
   47          
   48          int get_right_encoder(void)
   49          {
   50   1              int encoder_right;
   51   1              
   52   1              if(RIGHT_DIR == 1)
   53   1              {
   54   2                      encoder_right = ctimer_count_read(CTIM3_P04) * -1;
   55   2              }
   56   1              else
   57   1              {
C251 COMPILER V5.60.0,  encoder                                                            14/07/25  14:27:41  PAGE 2   

   58   2                      encoder_right = ctimer_count_read(CTIM3_P04);
   59   2              }
   60   1              
   61   1              ctimer_count_clean(CTIM3_P04);
   62   1              
   63   1              return encoder_right;
   64   1      }
   65          
   66          // 编码器去抖动
   67          int encoder_debounce(EncoderDebo_t* instance, int encoder)
   68          {
   69   1              if (myabs(encoder - instance->encoderlast) > ENCODER_JUMP_THRESHOLD && instance->count >= MIN_STABILITY_
             -COUNT)
   70   1              {
   71   2                      encoder = instance->encoderlast;
   72   2                      instance->count = 0;
   73   2              }
   74   1              else
   75   1              {
   76   2                      instance->encoderlast = encoder;
   77   2                      
   78   2                      instance->count++;
   79   2                      if (instance->count >= COUNTER_SAFETY_RESET)
   80   2                      {
   81   3                              // 可以保持清零，或者设置为一个不会立即触发抖动判断的值
   82   3                              instance->count = MIN_STABILITY_COUNT; 
   83   3                      }
   84   2              }
   85   1              
   86   1              return encoder;
   87   1      }
   88          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       398     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        30     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
