C251 COMPILER V5.60.0,  encoder                                                            12/07/25  22:01:39  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE encoder
OBJECT MODULE PLACED IN .\Out_File\encoder.obj
COMPILER INVOKED BY: D:\Software\Keil5\c251v560\C251\BIN\C251.EXE ..\USER\src\encoder.c LARGE INTR2 WARNINGLEVEL(3) OPTI
                    -MIZE(0,SPEED) BROWSE INCDIR(..\USER\inc;..\USER\src;..\libraries;..\seekfree_libraries;..\seekfree_peripheral) DEBUG PRI
                    -NT(.\Out_File\encoder.lst) OBJECT(.\Out_File\encoder.obj) 

stmt  level    source

    1          #include "encoder.h"
    2          
    3          #define ENCODER_JUMP_THRESHOLD    20  // 编码器读数突变的阈值（略大于正常的最大值）
    4          #define MIN_STABILITY_COUNT       5   // 判定为稳定状态所需的最小连续计数
    5          #define COUNTER_SAFETY_RESET   10000  // 计数器防溢出重置值
    6          
    7          Encoder_t EncoderL, EncoderR;
    8          EncoderDebo_t EncoderDeboL, EncoderDeboR;
    9          
   10          
   11          void encoder_init(void)
   12          {
   13   1          EncoderL.encoder_original = 0;
   14   1          EncoderL.encoder_integral = 0;
   15   1          EncoderL.encoder_final = 0;
   16   1      
   17   1          EncoderR.encoder_integral = 0;
   18   1          EncoderR.encoder_original = 0;
   19   1          EncoderR.encoder_final = 0;
   20   1              
   21   1              EncoderDeboL.encoderlast = 0;
   22   1              EncoderDeboL.count = 0;
   23   1              
   24   1              EncoderDeboR.encoderlast = 0;
   25   1              EncoderDeboR.count = 0;
   26   1              
   27   1              ctimer_count_init(CTIM0_P34);
   28   1              ctimer_count_init(CTIM3_P04);
   29   1      }
   30          
   31          int get_left_encoder(void)
   32          {
   33   1              int encoder_left;
   34   1              
   35   1              if(LEFT_DIR == 1)
   36   1              {
   37   2                      encoder_left = ctimer_count_read(CTIM0_P34);
   38   2              }
   39   1              else
   40   1              {
   41   2                      encoder_left = ctimer_count_read(CTIM0_P34) * -1;
   42   2              }
   43   1              
   44   1              ctimer_count_clean(CTIM0_P34);
   45   1              
   46   1              return encoder_left;
   47   1      }
   48          
   49          int get_right_encoder(void)
   50          {
   51   1              int encoder_right;
   52   1              
   53   1              if(RIGHT_DIR == 1)
   54   1              {
   55   2                      encoder_right = ctimer_count_read(CTIM3_P04) * -1;
   56   2              }
   57   1              else
C251 COMPILER V5.60.0,  encoder                                                            12/07/25  22:01:39  PAGE 2   

   58   1              {
   59   2                      encoder_right = ctimer_count_read(CTIM3_P04);
   60   2              }
   61   1              
   62   1              ctimer_count_clean(CTIM3_P04);
   63   1              
   64   1              return encoder_right;
   65   1      }
   66          
   67          int encoder_debounce(EncoderDebo_t* instance, int encoder)
   68          {
   69   1              // 使用宏替换魔法数，代码意图一目了然
   70   1              if (myabs(encoder - instance->encoderlast) > ENCODER_JUMP_THRESHOLD && instance->count >= MIN_STABILITY_
             -COUNT)
   71   1              {
   72   2                      encoder = instance->encoderlast;
   73   2                      instance->count = 0;
   74   2              }
   75   1              else
   76   1              {
   77   2                      instance->encoderlast = encoder;
   78   2                      
   79   2                      instance->count++;
   80   2                      if (instance->count >= COUNTER_SAFETY_RESET)
   81   2                      {
   82   3                              // 可以保持清零，或者设置为一个不会立即触发抖动判断的值
   83   3                              instance->count = MIN_STABILITY_COUNT; 
   84   3                      }
   85   2              }
   86   1              
   87   1              return encoder;
   88   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       398     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        30     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
