C251 COMPILER V5.60.0,  zf_function                                                        10/07/25  21:09:16  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_function
OBJECT MODULE PLACED IN .\Out_File\zf_function.obj
COMPILER INVOKED BY: D:\Software\Keil5\c251v560\C251\BIN\C251.EXE ..\seekfree_libraries\zf_function.c LARGE INTR2 WARNIN
                    -GLEVEL(3) OPTIMIZE(0,SPEED) BROWSE INCDIR(..\USER\inc;..\USER\src;..\libraries;..\seekfree_libraries;..\seekfree_periphe
                    -ral) DEBUG PRINT(.\Out_File\zf_function.lst) TABS(2) OBJECT(.\Out_File\zf_function.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * AI8051U Opensourec Library å³ï¼ˆAI8051U å¼€æºåº“ï¼‰æ˜¯ä¸€ä¸ªåŸºäºå®˜æ–¹ SDK æ¥å£çš„ç¬¬ä¸‰æ–¹å¼€æº
             -åº“
    3          * Copyright (c) 2022 SEEKFREE é€é£ç§‘æŠ€
    4          *
    5          * æœ¬æ–‡ä»¶æ˜¯STC å¼€æºåº“çš„ä¸€éƒ¨åˆ†
    6          *
    7          * AI8051U å¼€æºåº“ æ˜¯å…è´¹è½¯ä»¶
    8          * æ‚¨å¯ä»¥æ ¹æ®è‡ªç”±è½¯ä»¶åŸºé‡‘ä¼šå‘å¸ƒçš„ GPLï¼ˆGNU General Public Licenseï¼Œå³ GNUé€šç”¨å…¬å…±è®¸
             -å¯è¯ï¼‰çš„æ¡æ¬¾
    9          * å³ GPL çš„ç¬¬3ç‰ˆï¼ˆå³ GPL3.0ï¼‰æˆ–ï¼ˆæ‚¨é€‰æ‹©çš„ï¼‰ä»»ä½•åæ¥çš„ç‰ˆæœ¬ï¼Œé‡æ–°å‘å¸ƒå’Œ/æˆ–ä¿®æ”
             -¹å®ƒ
   10          *
   11          * æœ¬å¼€æºåº“çš„å‘å¸ƒæ˜¯å¸Œæœ›å®ƒèƒ½å‘æŒ¥ä½œç”¨ï¼Œä½†å¹¶æœªå¯¹å…¶ä½œä»»ä½•çš„ä¿è¯
   12          * ç”šè‡³æ²¡æœ‰éšå«çš„é€‚é”€æ€§æˆ–é€‚åˆç‰¹å®šç”¨é€”çš„ä¿è¯
   13          * æ›´å¤šç»†èŠ‚è¯·å‚è§ GPL
   14          *
   15          * æ‚¨åº”è¯¥åœ¨æ”¶åˆ°æœ¬å¼€æºåº“çš„åŒæ—¶æ”¶åˆ°ä¸€ä»½ GPL çš„å‰¯æœ¬
   16          * å¦‚æœæ²¡æœ‰ï¼Œè¯·å‚é˜…<https://www.gnu.org/licenses/>
   17          *
   18          * é¢å¤–æ³¨æ˜ï¼š
   19          * æœ¬å¼€æºåº“ä½¿ç”¨ GPL3.0 å¼€æºè®¸å¯è¯åè®® ä»¥ä¸Šè®¸å¯ç”³æ˜ä¸ºè¯‘æ–‡ç‰ˆæœ¬
   20          * è®¸å¯ç”³æ˜è‹±æ–‡ç‰ˆåœ¨ libraries/doc æ–‡ä»¶å¤¹ä¸‹çš„ GPL3_permission_statement.txt æ–‡ä»¶ä¸­
   21          * è®¸å¯è¯å‰¯æœ¬åœ¨ libraries æ–‡ä»¶å¤¹ä¸‹ å³è¯¥æ–‡ä»¶å¤¹ä¸‹çš„ LICENSE æ–‡ä»¶
   22          * æ¬¢è¿å„ä½ä½¿ç”¨å¹¶ä¼ æ’­æœ¬ç¨‹åº ä½†ä¿®æ”¹å†…å®¹æ—¶å¿…é¡»ä¿ç•™é€é£ç§‘æŠ€çš„ç‰ˆæƒå£°æ˜ï¼ˆå³æœ¬
             -å£°æ˜ï¼‰
   23          *
   24          * æ–‡ä»¶åç§°          
   25          * å…¬å¸åç§°          æˆéƒ½é€é£ç§‘æŠ€æœ‰é™å…¬å¸
   26          * ç‰ˆæœ¬ä¿¡æ¯          æŸ¥çœ‹ libraries/doc æ–‡ä»¶å¤¹å†… version æ–‡ä»¶ ç‰ˆæœ¬è¯´æ˜
   27          * å¼€å‘ç¯å¢ƒ          MDK FOR C251
   28          * é€‚ç”¨å¹³å°          AI8051U
   29          * åº—é“ºé“¾æ¥          https://seekfree.taobao.com/
   30          *
   31          * ä¿®æ”¹è®°å½•
   32          * æ—¥æœŸ              ä½œè€…           å¤‡æ³¨
   33          * 2024-08-01        å¤§W            first version
   34          *********************************************************************************************************
             -***********/
   35          
   36          
   37          #include "zf_function.h"
   38          #include <stdarg.h>  // åŒ…å«æ ‡å‡†å¯å˜å‚æ•°å®çš„å¤´æ–‡ä»¶
   39          #include <stdio.h>   // åŒ…å«æ ‡å‡†è¾“å…¥è¾“å‡ºçš„å¤´æ–‡ä»¶
   40          
   41          //-------------------------------------------------------------------------------------------------------
             -------------
   42          // å‡½æ•°ç®€ä»‹     è·å–æ•´å‹æ•°çš„æœ€å¤§å…¬çº¦æ•° ä¹ç« ç®—æœ¯ä¹‹æ›´ç›¸å‡æŸæœ¯
   43          // å‚æ•°è¯´æ˜     num1            æ•°å­—1
   44          // å‚æ•°è¯´æ˜     num2            æ•°å­—2
   45          // è¿”å›å‚æ•°     uint32          æœ€å¤§å…¬çº¦æ•°
   46          // ä½¿ç”¨ç¤ºä¾‹     return func_get_greatest_common_divisor(144, 36);               // è·å– 144 ä¸ 36 
             -çš„æœ€å¤§å…¬çº¦æ•°
   47          // å¤‡æ³¨ä¿¡æ¯     
   48          //-------------------------------------------------------------------------------------------------------
             -------------
C251 COMPILER V5.60.0,  zf_function                                                        10/07/25  21:09:16  PAGE 2   

   49          uint32 func_get_greatest_common_divisor (uint32 num1, uint32 num2)
   50          {
   51   1          while(num1 != num2)
   52   1          {
   53   2              if(num1 > num2)
   54   2              {
   55   3                  num1 = num1 - num2;
   56   3              }
   57   2              if(num1 < num2)
   58   2              {
   59   3                  num2 = num2 - num1;
   60   3              }
   61   2          }
   62   1          return num1;
   63   1      }
   64          
   65          //-------------------------------------------------------------------------------------------------------
             -------------
   66          // å‡½æ•°ç®€ä»‹     è½¯ä»¶å»¶æ—¶
   67          // å‚æ•°è¯´æ˜     t               å»¶æ—¶æ—¶é—´
   68          // è¿”å›å‚æ•°     void
   69          // ä½¿ç”¨ç¤ºä¾‹     func_soft_delay(100);
   70          // å¤‡æ³¨ä¿¡æ¯     
   71          //-------------------------------------------------------------------------------------------------------
             -------------
   72          void func_soft_delay (volatile long t)
   73          {
   74   1          while(t --);
   75   1      }
   76          
   77          //-------------------------------------------------------------------------------------------------------
             -------------
   78          // å‡½æ•°ç®€ä»‹     å­—ç¬¦ä¸²è½¬æ•´å½¢æ•°å­— æ•°æ®èŒƒå›´æ˜¯ [-32768,32767]
   79          // å‚æ•°è¯´æ˜     *str            ä¼ å…¥å­—ç¬¦ä¸² å¯å¸¦ç¬¦å·
   80          // è¿”å›å‚æ•°     int32           è½¬æ¢åçš„æ•°æ®          
   81          // ä½¿ç”¨ç¤ºä¾‹     int32 dat = func_str_to_int("-100");
   82          // å¤‡æ³¨ä¿¡æ¯     
   83          //-------------------------------------------------------------------------------------------------------
             -------------
   84          int32 func_str_to_int (char *str)
   85          {
   86   1          uint8 sign = 0;                                                             // æ ‡è®°ç¬¦å· 0-æ­£æ•° 
             -1-è´Ÿæ•°
   87   1          int32 temp = 0;                                                             // ä¸´æ—¶è®¡ç®—å˜é‡
   88   1        //zf_assert(str != NULL);
   89   1        do
   90   1          {
   91   2              if(NULL == str)
   92   2              {
   93   3                  break;
   94   3              }
   95   2      
   96   2              if('-' == *str)                                                         // å¦‚æœç¬¬ä¸€ä¸ªå­—ç¬¦æ
             -˜¯è´Ÿå·
   97   2              {
   98   3                  sign = 1;                                                           // æ ‡è®°è´Ÿæ•°
   99   3                  str ++;
  100   3              }
  101   2              else if('+' == *str)                                                    // å¦‚æœç¬¬ä¸€ä¸ªå­—ç¬¦æ
             -˜¯æ­£å·
  102   2              {
  103   3                  str ++;
  104   3              }
  105   2      
  106   2              while(('0' <= *str) && ('9' >= *str))                                   // ç¡®å®šè¿™æ˜¯ä¸ªæ•°å­—
  107   2              {
C251 COMPILER V5.60.0,  zf_function                                                        10/07/25  21:09:16  PAGE 3   

  108   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                          // è®¡ç®—æ•°å€¼
  109   3                  str ++;
  110   3              }
  111   2      
  112   2              if(sign)
  113   2              {
  114   3                  temp = -temp;
  115   3              }
  116   2          }while(0);
  117   1          return temp;
  118   1      }
  119          
  120          //-------------------------------------------------------------------------------------------------------
             -------------
  121          // å‡½æ•°ç®€ä»‹     æ•´å½¢æ•°å­—è½¬å­—ç¬¦ä¸² æ•°æ®èŒƒå›´æ˜¯ [-32768,32767]
  122          // å‚æ•°è¯´æ˜     *str            å­—ç¬¦ä¸²æŒ‡é’ˆ
  123          // å‚æ•°è¯´æ˜     number          ä¼ å…¥çš„æ•°æ®
  124          // è¿”å›å‚æ•°     void
  125          // ä½¿ç”¨ç¤ºä¾‹     func_int_to_str(data_buffer, -300);
  126          // å¤‡æ³¨ä¿¡æ¯     
  127          //-------------------------------------------------------------------------------------------------------
             -------------
  128          void func_int_to_str (char *str, int32 number)
  129          {
  130   1          uint8 data_temp[16];                                                        // ç¼“å†²åŒº
  131   1          uint8 temp_bit = 0;                                                              // æ•°å­—ä½æ•°
  132   1          int32 number_temp = 0;
  133   1          //zf_assert(str != NULL);
  134   1          do
  135   1          {
  136   2              if(NULL == str)
  137   2              {
  138   3                  break;
  139   3              }
  140   2      
  141   2              if(0 > number)                                                          // è´Ÿæ•°
  142   2              {
  143   3                  *str ++ = '-';
  144   3                  number = -number;
  145   3              }
  146   2              else if(0 == number)                                                    // æˆ–è€…è¿™æ˜¯ä¸ª 0
  147   2              {
  148   3                  *str = '0';
  149   3                  break;
  150   3              }
  151   2      
  152   2              while(0 != number)                                                      // å¾ªç¯ç›´åˆ°æ•°å€¼å½’é
             -›¶
  153   2              {
  154   3                  number_temp = number % 10;
  155   3                  data_temp[temp_bit ++] = func_abs(number_temp);                          // å€’åºå°†æ•°å€¼æ
             -å–å‡ºæ¥
  156   3                  number /= 10;                                                       // å‰Šå‡è¢«æå–çš„ä¸ªä
             -½æ•°
  157   3              }
  158   2              while(0 != temp_bit)                                                         // æå–çš„æ•°å­—ä¸
             -ªæ•°é€’å‡å¤„ç†
  159   2              {
  160   3                  *str ++ = (data_temp[temp_bit - 1] + 0x30);                              // å°†æ•°å­—ä»å€’åº
             -æ•°ç»„ä¸­å€’åºå–å‡º å˜æˆæ­£åºæ”¾å…¥å­—ç¬¦ä¸²
  161   3                  temp_bit --;
  162   3              }
  163   2          }while(0);
  164   1      }
  165          
  166          //-------------------------------------------------------------------------------------------------------
C251 COMPILER V5.60.0,  zf_function                                                        10/07/25  21:09:16  PAGE 4   

             -------------
  167          // å‡½æ•°ç®€ä»‹     å­—ç¬¦ä¸²è½¬æ•´å½¢æ•°å­— æ•°æ®èŒƒå›´æ˜¯ [0,65535]
  168          // å‚æ•°è¯´æ˜     *str            ä¼ å…¥å­—ç¬¦ä¸² æ— ç¬¦å·
  169          // è¿”å›å‚æ•°     uint32          è½¬æ¢åçš„æ•°æ®          
  170          // ä½¿ç”¨ç¤ºä¾‹     uint32 dat = func_str_to_uint("100");
  171          // å¤‡æ³¨ä¿¡æ¯     
  172          //-------------------------------------------------------------------------------------------------------
             -------------
  173          uint32 func_str_to_uint (char *str)
  174          {
  175   1        uint32 temp = 0;                                                            // ä¸´æ—¶è®¡ç®—å˜é‡
  176   1          //zf_assert(str != NULL);
  177   1      
  178   1          do
  179   1          {
  180   2              if(NULL == str)
  181   2              {
  182   3                  break;
  183   3              }
  184   2      
  185   2              while(('0' <= *str) && ('9' >= *str))                                  // ç¡®å®šè¿™æ˜¯ä¸ªæ•°å­—
  186   2              {
  187   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                         // è®¡ç®—æ•°å€¼
  188   3                  str ++;
  189   3              }
  190   2          }while(0);
  191   1      
  192   1          return temp;
  193   1      }
  194          
  195          //-------------------------------------------------------------------------------------------------------
             -------------
  196          // å‡½æ•°ç®€ä»‹     æ•´å½¢æ•°å­—è½¬å­—ç¬¦ä¸² æ•°æ®èŒƒå›´æ˜¯ [0,65535]
  197          // å‚æ•°è¯´æ˜     *str            å­—ç¬¦ä¸²æŒ‡é’ˆ
  198          // å‚æ•°è¯´æ˜     number          ä¼ å…¥çš„æ•°æ®
  199          // è¿”å›å‚æ•°     void
  200          // ä½¿ç”¨ç¤ºä¾‹     func_uint_to_str(data_buffer, 300);
  201          // å¤‡æ³¨ä¿¡æ¯     
  202          //-------------------------------------------------------------------------------------------------------
             -------------
  203          void func_uint_to_str (char *str, uint32 number)
  204          {
  205   1          int8 data_temp[16];                                                         // ç¼“å†²åŒº
  206   1          uint8 temp_bit = 0;                                                              // æ•°å­—ä½æ•°
  207   1          
  208   1        //zf_assert(str != NULL);
  209   1          
  210   1        do
  211   1          {
  212   2              if(NULL == str)
  213   2              {
  214   3                  break;
  215   3              }
  216   2      
  217   2              if(0 == number)                                                         // è¿™æ˜¯ä¸ª 0
  218   2              {
  219   3                  *str = '0';
  220   3                  break;
  221   3              }
  222   2      
  223   2              while(0 != number)                                                      // å¾ªç¯ç›´åˆ°æ•°å€¼å½’é
             -›¶
  224   2              {
  225   3                  data_temp[temp_bit ++] = (number % 10);                                  // å€’åºå°†æ•°å€¼æ
             -å–å‡ºæ¥
  226   3                  number /= 10;                                                       // å‰Šå‡è¢«æå–çš„ä¸ªä
C251 COMPILER V5.60.0,  zf_function                                                        10/07/25  21:09:16  PAGE 5   

             -½æ•°
  227   3              }
  228   2              while(0 != temp_bit)                                                         // æå–çš„æ•°å­—ä¸
             -ªæ•°é€’å‡å¤„ç†
  229   2              {
  230   3                  *str ++ = (data_temp[temp_bit - 1] + 0x30);                              // å°†æ•°å­—ä»å€’åº
             -æ•°ç»„ä¸­å€’åºå–å‡º å˜æˆæ­£åºæ”¾å…¥å­—ç¬¦ä¸²
  231   3                  temp_bit --;
  232   3              }
  233   2          }while(0);
  234   1      }
  235          
  236          //-------------------------------------------------------------------------------------------------------
             -------------
  237          // å‡½æ•°ç®€ä»‹     å­—ç¬¦ä¸²è½¬æµ®ç‚¹æ•° æœ‰æ•ˆç´¯è®¡ç²¾åº¦ä¸ºå°æ•°ç‚¹åå…­ä½
  238          // å‚æ•°è¯´æ˜     *str            ä¼ å…¥å­—ç¬¦ä¸² å¯å¸¦ç¬¦å·
  239          // è¿”å›å‚æ•°     float           è½¬æ¢åçš„æ•°æ®          
  240          // ä½¿ç”¨ç¤ºä¾‹     float dat = func_str_to_float("-100.2");
  241          // å¤‡æ³¨ä¿¡æ¯     
  242          //-------------------------------------------------------------------------------------------------------
             -------------
  243          float func_str_to_float (char *str)
  244          {
  245   1          uint8 sign = 0;                                                             // æ ‡è®°ç¬¦å· 0-æ­£æ•° 
             -1-è´Ÿæ•°
  246   1          float temp = 0.0;                                                           // ä¸´æ—¶è®¡ç®—å˜é‡ æ•´
             -æ•°éƒ¨åˆ†
  247   1          float temp_point = 0.0;                                                     // ä¸´æ—¶è®¡ç®—å˜é‡ å°
             -æ•°éƒ¨åˆ†
  248   1          float point_bit = 1;                                                        // å°æ•°ç´¯è®¡é™¤æ•°
  249   1          
  250   1        //zf_assert(str != NULL);
  251   1          
  252   1        do
  253   1          {
  254   2              if(NULL == str)
  255   2              {
  256   3                  break;
  257   3              }
  258   2      
  259   2              if('-' == *str)                                                         // è´Ÿæ•°
  260   2              {
  261   3                  sign = 1;                                                           // æ ‡è®°è´Ÿæ•°
  262   3                  str ++;
  263   3              }
  264   2              else if('+' == *str)                                                    // å¦‚æœç¬¬ä¸€ä¸ªå­—ç¬¦æ
             -˜¯æ­£å·
  265   2              {
  266   3                  str ++;
  267   3              }
  268   2      
  269   2              // æå–æ•´æ•°éƒ¨åˆ†
  270   2              while(('0' <= *str) && ('9' >= *str))                                   // ç¡®å®šè¿™æ˜¯ä¸ªæ•°å­—
  271   2              {
  272   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                          // å°†æ•°å€¼æå–å‡ºæ¥
  273   3                  str ++;
  274   3              }
  275   2              if('.' == *str)
  276   2              {
  277   3                  str ++;
  278   3                  while(('0' <= *str) && ('9' >= *str) && point_bit < 1000000.0)      // ç¡®è®¤è¿™æ˜¯ä¸ªæ•°å­— 
             -å¹¶ä¸”ç²¾åº¦æ§åˆ¶è¿˜æ²¡åˆ°å…­ä½
  279   3                  {
  280   4                      temp_point = temp_point * 10 + ((uint8)(*str) - 0x30);          // æå–å°æ•°éƒ¨åˆ†æ•°å
             -€¼
  281   4                      point_bit *= 10;                                                // è®¡ç®—è¿™éƒ¨åˆ†å°æ•°ç
C251 COMPILER V5.60.0,  zf_function                                                        10/07/25  21:09:16  PAGE 6   

             -š„é™¤æ•°
  282   4                      str ++;
  283   4                  }
  284   3                  temp_point /= point_bit;                                            // è®¡ç®—å°æ•°
  285   3              }
  286   2              temp += temp_point;                                                     // å°†æ•°å€¼æ‹¼åˆ
  287   2      
  288   2              if(sign)
  289   2              {
  290   3                  temp = -temp;
  291   3              }
  292   2          }while(0);
  293   1          return temp;
  294   1      }
  295          
  296          //-------------------------------------------------------------------------------------------------------
             -------------
  297          // å‡½æ•°ç®€ä»‹     æµ®ç‚¹æ•°å­—è½¬å­—ç¬¦ä¸²
  298          // å‚æ•°è¯´æ˜     *str            å­—ç¬¦ä¸²æŒ‡é’ˆ
  299          // å‚æ•°è¯´æ˜     number          ä¼ å…¥çš„æ•°æ®
  300          // å‚æ•°è¯´æ˜     point_bit       å°æ•°ç‚¹ç²¾åº¦
  301          // è¿”å›å‚æ•°     void
  302          // ä½¿ç”¨ç¤ºä¾‹     func_float_to_str(data_buffer, 3.1415, 2);                      // ç»“æœè¾“å‡º data_
             -buffer = "3.14"
  303          // å¤‡æ³¨ä¿¡æ¯     
  304          //-------------------------------------------------------------------------------------------------------
             -------------
  305          void func_float_to_str (char *str, float number, uint8 point_bit)
  306          {
  307   1          int32 data_int = 0;                                                           // æ•´æ•°éƒ¨åˆ†
  308   1          int32 data_float = 0.0;                                                       // å°æ•°éƒ¨åˆ†
  309   1          int32 data_temp[8];                                                           // æ•´æ•°å­—ç¬¦ç¼“å†²
  310   1          int32 data_temp_point[6];                                                     // å°æ•°å­—ç¬¦ç¼“å†²
  311   1          uint8 temp_bit = point_bit;                                                      // è½¬æ¢ç²¾åº¦ä½æ•
             -°
  312   1          
  313   1        //zf_assert(str != NULL);
  314   1          
  315   1        do
  316   1          {
  317   2              if(NULL == str)
  318   2              {
  319   3                  break;
  320   3              }
  321   2      
  322   2              // æå–æ•´æ•°éƒ¨åˆ†
  323   2              data_int = (int)number;                                                 // ç›´æ¥å¼ºåˆ¶è½¬æ¢ä¸º 
             -int
  324   2              if(0 > number)                                                          // åˆ¤æ–­æºæ•°æ®æ˜¯æ­£æ
             -•°è¿˜æ˜¯è´Ÿæ•°
  325   2              {
  326   3                  *str ++ = '-';
  327   3              }
  328   2              else if(0.0 == number)                                                  // å¦‚æœæ˜¯ä¸ª 0
  329   2              {
  330   3                  *str ++ = '0';
  331   3                  *str ++ = '.';
  332   3                  *str = '0';
  333   3                  break;
  334   3              }
  335   2      
  336   2              // æå–å°æ•°éƒ¨åˆ†
  337   2              number = number - data_int;                                             // å‡å»æ•´æ•°éƒ¨åˆ†å³å
             -¯
  338   2              while(temp_bit --)
  339   2              {
C251 COMPILER V5.60.0,  zf_function                                                        10/07/25  21:09:16  PAGE 7   

  340   3                  number = number * 10;                                               // å°†éœ€è¦çš„å°æ•°ä½æ
             -•°æå–åˆ°æ•´æ•°éƒ¨åˆ†
  341   3              }
  342   2              data_float = (int)number;                                               // è·å–è¿™éƒ¨åˆ†æ•°å€¼
  343   2      
  344   2              // æ•´æ•°éƒ¨åˆ†è½¬ä¸ºå­—ç¬¦ä¸²
  345   2              temp_bit = 0;
  346   2              do
  347   2              {
  348   3                  data_temp[temp_bit ++] = data_int % 10;                                  // å°†æ•´æ•°éƒ¨åˆ†å€
             -’åºå†™å…¥å­—ç¬¦ç¼“å†²åŒº
  349   3                  data_int /= 10;
  350   3              }while(0 != data_int);
  351   2              while(0 != temp_bit)
  352   2              {
  353   3                  *str ++ = (func_abs(data_temp[temp_bit - 1]) + 0x30);                    // å†å€’åºå°†å€’åº
             -çš„æ•°å€¼å†™å…¥å­—ç¬¦ä¸² å¾—åˆ°æ­£åºæ•°å€¼
  354   3                  temp_bit --;
  355   3              }
  356   2      
  357   2              // å°æ•°éƒ¨åˆ†è½¬ä¸ºå­—ç¬¦ä¸²
  358   2              if(point_bit != 0)
  359   2              {
  360   3                  temp_bit = 0;
  361   3                  *str ++ = '.';
  362   3                  if(0 == data_float)
  363   3                  {
  364   4                      *str = '0';
  365   4                  }
  366   3                  else
  367   3                  {
  368   4                      while(0 != point_bit)                                           // åˆ¤æ–­æœ‰æ•ˆä½æ•°
  369   4                      {
  370   5                          data_temp_point[temp_bit ++] = data_float % 10;                  // å€’åºå†™å…¥å­—ç¬
             -¦ç¼“å†²åŒº
  371   5                          data_float /= 10;
  372   5                          point_bit --;                                                
  373   5                      }
  374   4                      while(0 != temp_bit)
  375   4                      {
  376   5                          *str ++ = (func_abs(data_temp_point[temp_bit - 1]) + 0x30);      // å†å€’åºå°†å€’åº
             -çš„æ•°å€¼å†™å…¥å­—ç¬¦ä¸² å¾—åˆ°æ­£åºæ•°å€¼
  377   5                          temp_bit --;
  378   5                      }
  379   4                  }
  380   3              }
  381   2          }while(0);
  382   1      }
  383          
  384          //-------------------------------------------------------------------------------------------------------
             -------------
  385          // å‡½æ•°ç®€ä»‹     å­—ç¬¦ä¸²è½¬æµ®ç‚¹æ•° æœ‰æ•ˆç´¯è®¡ç²¾åº¦ä¸ºå°æ•°ç‚¹åä¹ä½
  386          // å‚æ•°è¯´æ˜     str             ä¼ å…¥å­—ç¬¦ä¸² å¯å¸¦ç¬¦å·
  387          // è¿”å›å‚æ•°     double          è½¬æ¢åçš„æ•°æ®          
  388          // ä½¿ç”¨ç¤ºä¾‹     double dat = func_str_to_double("-100.2");
  389          // å¤‡æ³¨ä¿¡æ¯     
  390          //-------------------------------------------------------------------------------------------------------
             -------------
  391          double func_str_to_double (char *str)
  392          {
  393   1          uint8 sign = 0;                                                             // æ ‡è®°ç¬¦å· 0-æ­£æ•° 
             -1-è´Ÿæ•°
  394   1          double temp = 0.0;                                                          // ä¸´æ—¶è®¡ç®—å˜é‡ æ•´
             -æ•°éƒ¨åˆ†
  395   1          double temp_point = 0.0;                                                    // ä¸´æ—¶è®¡ç®—å˜é‡ å°
             -æ•°éƒ¨åˆ†
C251 COMPILER V5.60.0,  zf_function                                                        10/07/25  21:09:16  PAGE 8   

  396   1          double point_bit = 1;                                                       // å°æ•°ç´¯è®¡é™¤æ•°
  397   1          
  398   1        //zf_assert(str != NULL);
  399   1          
  400   1        do
  401   1          {
  402   2              if(NULL == str)
  403   2              {
  404   3                  break;
  405   3              }
  406   2      
  407   2              if('-' == *str)                                                         // è´Ÿæ•°
  408   2              {
  409   3                  sign = 1;                                                           // æ ‡è®°è´Ÿæ•°
  410   3                  str ++;
  411   3              }
  412   2              else if('+' == *str)                                                    // å¦‚æœç¬¬ä¸€ä¸ªå­—ç¬¦æ
             -˜¯æ­£å·
  413   2              {
  414   3                  str ++;
  415   3              }
  416   2      
  417   2              // æå–æ•´æ•°éƒ¨åˆ†
  418   2              while(('0' <= *str) && ('9' >= *str))                                   // ç¡®å®šè¿™æ˜¯ä¸ªæ•°å­—
  419   2              {
  420   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                          // å°†æ•°å€¼æå–å‡ºæ¥
  421   3                  str ++;
  422   3              }
  423   2              if('.' == *str)
  424   2              {
  425   3                  str ++;
  426   3                  while(('0' <= *str) && ('9' >= *str) && point_bit < 1000000000.0)   // ç¡®è®¤è¿™æ˜¯ä¸ªæ•°å­— 
             -å¹¶ä¸”ç²¾åº¦æ§åˆ¶è¿˜æ²¡åˆ°ä¹ä½
  427   3                  {
  428   4                      temp_point = temp_point * 10 + ((uint8)(*str) - 0x30);          // æå–å°æ•°éƒ¨åˆ†æ•°å
             -€¼
  429   4                      point_bit *= 10;                                                // è®¡ç®—è¿™éƒ¨åˆ†å°æ•°ç
             -š„é™¤æ•°
  430   4                      str ++;
  431   4                  }
  432   3                  temp_point /= point_bit;                                            // è®¡ç®—å°æ•°
  433   3              }
  434   2              temp += temp_point;                                                     // å°†æ•°å€¼æ‹¼åˆ
  435   2      
  436   2              if(sign)
  437   2              {
  438   3                  temp = -temp;
  439   3              }
  440   2          }while(0);
  441   1          return temp;
  442   1      
  443   1      }
  444          
  445          //-------------------------------------------------------------------------------------------------------
             -------------
  446          // å‡½æ•°ç®€ä»‹     æµ®ç‚¹æ•°å­—è½¬å­—ç¬¦ä¸²
  447          // å‚æ•°è¯´æ˜     *str            å­—ç¬¦ä¸²æŒ‡é’ˆ
  448          // å‚æ•°è¯´æ˜     number          ä¼ å…¥çš„æ•°æ®
  449          // å‚æ•°è¯´æ˜     point_bit       å°æ•°ç‚¹ç²¾åº¦
  450          // è¿”å›å‚æ•°     void
  451          // ä½¿ç”¨ç¤ºä¾‹     func_double_to_str(data_buffer, 3.1415, 2);                     // ç»“æœè¾“å‡º data_
             -buffer = "3.14"
  452          // å¤‡æ³¨ä¿¡æ¯     
  453          //-------------------------------------------------------------------------------------------------------
             -------------
  454          void func_double_to_str (char *str, double number, uint8 point_bit)
C251 COMPILER V5.60.0,  zf_function                                                        10/07/25  21:09:16  PAGE 9   

  455          {
  456   1          int32 data_int = 0;                                                           // æ•´æ•°éƒ¨åˆ†
  457   1          int32 data_float = 0.0;                                                       // å°æ•°éƒ¨åˆ†
  458   1          int32 data_temp[12];                                                          // æ•´æ•°å­—ç¬¦ç¼“å†²
  459   1          int32 data_temp_point[9];                                                     // å°æ•°å­—ç¬¦ç¼“å†²
  460   1          uint8 temp_bit = point_bit;                                                      // è½¬æ¢ç²¾åº¦ä½æ•
             -°
  461   1          
  462   1        //zf_assert(str != NULL);
  463   1          
  464   1        do
  465   1          {
  466   2              if(NULL == str)
  467   2              {
  468   3                  break;
  469   3              }
  470   2      
  471   2              // æå–æ•´æ•°éƒ¨åˆ†
  472   2              data_int = (int32)number;                                                 // ç›´æ¥å¼ºåˆ¶è½¬æ¢ä¸
             -º int
  473   2              if(0 > number)                                                          // åˆ¤æ–­æºæ•°æ®æ˜¯æ­£æ
             -•°è¿˜æ˜¯è´Ÿæ•°
  474   2              {
  475   3                  *str ++ = '-';
  476   3              }
  477   2              else if(0.0 == number)                                                  // å¦‚æœæ˜¯ä¸ª 0
  478   2              {
  479   3                  *str ++ = '0';
  480   3                  *str ++ = '.';
  481   3                  *str = '0';
  482   3                  break;
  483   3              }
  484   2      
  485   2              // æå–å°æ•°éƒ¨åˆ†
  486   2              number = number - data_int;                                             // å‡å»æ•´æ•°éƒ¨åˆ†å³å
             -¯
  487   2              while(temp_bit --)
  488   2              {
  489   3                  number = number * 10;                                               // å°†éœ€è¦çš„å°æ•°ä½æ
             -•°æå–åˆ°æ•´æ•°éƒ¨åˆ†
  490   3              }
  491   2              data_float = (int32)number;                                               // è·å–è¿™éƒ¨åˆ†æ•°å€
             -¼
  492   2      
  493   2              // æ•´æ•°éƒ¨åˆ†è½¬ä¸ºå­—ç¬¦ä¸²
  494   2              temp_bit = 0;
  495   2              do
  496   2              {
  497   3                  data_temp[temp_bit ++] = data_int % 10;                                  // å°†æ•´æ•°éƒ¨åˆ†å€
             -’åºå†™å…¥å­—ç¬¦ç¼“å†²åŒº
  498   3                  data_int /= 10;
  499   3              }while(0 != data_int);
  500   2              while(0 != temp_bit)
  501   2              {
  502   3                  *str ++ = (func_abs(data_temp[temp_bit - 1]) + 0x30);                    // å†å€’åºå°†å€’åº
             -çš„æ•°å€¼å†™å…¥å­—ç¬¦ä¸² å¾—åˆ°æ­£åºæ•°å€¼
  503   3                  temp_bit --;
  504   3              }
  505   2      
  506   2              // å°æ•°éƒ¨åˆ†è½¬ä¸ºå­—ç¬¦ä¸²
  507   2              if(point_bit != 0)
  508   2              {
  509   3                  temp_bit = 0;
  510   3                  *str ++ = '.';
  511   3                  if(0 == data_float)
  512   3                      *str = '0';
C251 COMPILER V5.60.0,  zf_function                                                        10/07/25  21:09:16  PAGE 10  

  513   3                  else
  514   3                  {
  515   4                      while(0 != point_bit)                                           // åˆ¤æ–­æœ‰æ•ˆä½æ•°
  516   4                      {
  517   5                          data_temp_point[temp_bit ++] = data_float % 10;                  // å€’åºå†™å…¥å­—ç¬
             -¦ç¼“å†²åŒº
  518   5                          data_float /= 10;
  519   5                          point_bit --;                                                
  520   5                      }
  521   4                      while(0 != temp_bit)
  522   4                      {
  523   5                          *str ++ = (func_abs(data_temp_point[temp_bit - 1]) + 0x30);      // å†å€’åºå°†å€’åº
             -çš„æ•°å€¼å†™å…¥å­—ç¬¦ä¸² å¾—åˆ°æ­£åºæ•°å€¼
  524   5                          temp_bit --;
  525   5                      }
  526   4                  }
  527   3              }
  528   2          }while(0);
  529   1      }
  530          
  531          //-------------------------------------------------------------------------------------------------------
             -------------
  532          // å‡½æ•°ç®€ä»‹     å­—ç¬¦ä¸²è½¬ Hex
  533          // å‚æ•°è¯´æ˜     str             ä¼ å…¥å­—ç¬¦ä¸² æ— ç¬¦å·
  534          // è¿”å›å‚æ•°     uint32          è½¬æ¢åçš„æ•°æ®
  535          // ä½¿ç”¨ç¤ºä¾‹     uint32 dat = func_str_to_hex("0x11");
  536          // å¤‡æ³¨ä¿¡æ¯     
  537          //-------------------------------------------------------------------------------------------------------
             -------------
  538          uint32 func_str_to_hex (char *str)
  539          {
  540   1          uint32 str_len = strlen(str);                                               // å­—ç¬¦ä¸²é•¿
  541   1          uint32 result_data = 0;                                                     // ç»“æœç¼“å­˜
  542   1          uint8 temp = 0;                                                             // è®¡ç®—å˜é‡
  543   1          uint8 flag = 0;                                                             // æ ‡å¿—ä½
  544   1      
  545   1        //zf_assert(str != NULL);
  546   1        
  547   1          do
  548   1          {
  549   2              if(NULL == str)
  550   2              {
  551   3                  break;
  552   3              }
  553   2      
  554   2              if(flag)
  555   2              {
  556   3                  if(('a' <= *str) && ('f' >= *str))
  557   3                  {
  558   4                      temp = (*str - 87);
  559   4                  }
  560   3                  else if(('A' <= *str) && ('F' >= *str))
  561   3                  {
  562   4                      temp = (*str - 55);
  563   4                  }
  564   3                  else if(('0' <= *str) && ('9' >= *str))
  565   3                  {
  566   4                      temp = (*str - 48);
  567   4                  }
  568   3                  else
  569   3                  {
  570   4                      break;
  571   4                  }
  572   3                  result_data = ((result_data << 4) | (temp & 0x0F));
  573   3              }
  574   2              else
C251 COMPILER V5.60.0,  zf_function                                                        10/07/25  21:09:16  PAGE 11  

  575   2              {
  576   3      //            if(strncmp("0x", str, 2))
  577   3                  if((*str == '0') && (*(str + 1) == 'x'))
  578   3                  {
  579   4                      str ++;
  580   4                      flag = 1;
  581   4                  }
  582   3              }
  583   2              str ++;
  584   2          }while(str_len --);
  585   1      
  586   1          return result_data;
  587   1      }
  588          
  589          //-------------------------------------------------------------------------------------------------------
             -------------
  590          // å‡½æ•°ç®€ä»‹     Hex è½¬å­—ç¬¦ä¸²
  591          // å‚æ•°è¯´æ˜     *str            å­—ç¬¦ä¸²æŒ‡é’ˆ
  592          // å‚æ•°è¯´æ˜     number          ä¼ å…¥çš„æ•°æ®
  593          // è¿”å›å‚æ•°     void
  594          // ä½¿ç”¨ç¤ºä¾‹     func_hex_to_str(data_buffer, 0x11);                             // ç»“æœè¾“å‡º data_
             -buffer = "0x11"
  595          // å¤‡æ³¨ä¿¡æ¯     
  596          //-------------------------------------------------------------------------------------------------------
             -------------
  597          void func_hex_to_str (char *str, uint32 number)
  598          {
  599   1          const char hex_index[16] = {
  600   1              '0', '1', '2', '3',
  601   1              '4', '5', '6', '7',
  602   1              '8', '9', 'A', 'B',
  603   1              'C', 'D', 'E', 'F'};
  604   1          int8 data_temp[12];                                                         // ç¼“å†²åŒº
  605   1          uint8 temp_bit = 0;                                                              // æ•°å­—ä½æ•°
  606   1      
  607   1          //zf_assert(str != NULL);
  608   1          
  609   1          *str++ = '0';
  610   1          *str++ = 'x';
  611   1          do
  612   1          {
  613   2              if(NULL == str)
  614   2              {
  615   3                  break;
  616   3              }
  617   2      
  618   2              if(0 == number)                                                         // è¿™æ˜¯ä¸ª 0
  619   2              {
  620   3                  *str = '0';
  621   3                  break;
  622   3              }
  623   2      
  624   2              while(0 != number)                                                      // å¾ªç¯ç›´åˆ°æ•°å€¼å½’é
             -›¶
  625   2              {
  626   3                  data_temp[temp_bit ++] = (number & 0xF);                                 // å€’åºå°†æ•°å€¼æ
             -å–å‡ºæ¥
  627   3                  number >>= 4;                                                       // å‰Šå‡è¢«æå–çš„ä¸ªä
             -½æ•°
  628   3              }
  629   2              while(0 != temp_bit)                                                         // æå–çš„æ•°å­—ä¸
             -ªæ•°é€’å‡å¤„ç†
  630   2              {
  631   3                  *str ++ = hex_index[data_temp[temp_bit - 1]];                            // å°†æ•°å­—ä»å€’åº
             -æ•°ç»„ä¸­å€’åºå–å‡º å˜æˆæ­£åºæ”¾å…¥å­—ç¬¦ä¸²
  632   3                  temp_bit --;
C251 COMPILER V5.60.0,  zf_function                                                        10/07/25  21:09:16  PAGE 12  

  633   3              }
  634   2          }while(0);
  635   1      }
  636          
  637          ////-----------------------------------------------------------------------------------------------------
             ---------------
  638          //// å‡½æ•°ç®€ä»‹     æ•°å­—è½¬æ¢ä¸º ASCII å€¼
  639          //// å‚æ•°è¯´æ˜     dat             ä¼ å…¥çš„æ•°æ®
  640          //// å‚æ•°è¯´æ˜     *p              æ•°æ®ç¼“å†²
  641          //// å‚æ•°è¯´æ˜     neg_type        æ•°æ®ç±»å‹
  642          //// å‚æ•°è¯´æ˜     radix           è¿›åˆ¶
  643          //// è¿”å›å‚æ•°     uint8           æ•°æ®
  644          //// ä½¿ç”¨ç¤ºä¾‹     number_conversion_ascii((uint32)ival, vstr, 1, 10);
  645          //// å¤‡æ³¨ä¿¡æ¯     æœ¬å‡½æ•°åœ¨æ–‡ä»¶å†…éƒ¨è°ƒç”¨ ç”¨æˆ·ä¸ç”¨å…³æ³¨ ä¹Ÿä¸å¯ä¿®æ”¹
  646          ////-----------------------------------------------------------------------------------------------------
             ---------------
  647          //static uint8 number_conversion_ascii (uint32 dat, int8 *p, uint8 neg_type, uint8 radix)
  648          //{
  649          //    int32   neg_dat;
  650          //    uint32  pos_dat;
  651          //    uint8   temp_data = 0;
  652          //    uint8   valid_num = 0;
  653          
  654          //    if(neg_type)
  655          //    {
  656          //        neg_dat = (int32)dat;
  657          //        if(0 > neg_dat)
  658          //        {
  659          //            neg_dat = -neg_dat;
  660          //        }
  661          //        while(1)
  662          //        {
  663          //            *p = neg_dat%radix + '0';
  664          //            neg_dat = neg_dat/radix;
  665          //            valid_num ++;
  666          
  667          //            if(!neg_dat)
  668          //            {
  669          //                break;
  670          //            }
  671          //            p ++;
  672          //        }
  673          //    }
  674          //    else
  675          //    {
  676          //        pos_dat = dat;
  677          //        while(1)
  678          //        {
  679          //            temp_data = pos_dat%radix;
  680          //            if(10 <= temp_data)
  681          //            {
  682          //                temp_data += 'A'-10;
  683          //            }
  684          //            else
  685          //            {
  686          //                temp_data += '0';
  687          //            }
  688          
  689          //            *p = temp_data;
  690          
  691          //            pos_dat = pos_dat/radix;
  692          //            valid_num ++;
  693          
  694          //            if(!pos_dat)
  695          //            {
  696          //                break;
C251 COMPILER V5.60.0,  zf_function                                                        10/07/25  21:09:16  PAGE 13  

  697          //            }
  698          //            p ++;
  699          //        }
  700          //    }
  701          //    return valid_num;
  702          //}
  703          
  704          ////-----------------------------------------------------------------------------------------------------
             ---------------
  705          //// å‡½æ•°ç®€ä»‹     printf æ˜¾ç¤ºè½¬æ¢
  706          //// å‚æ•°è¯´æ˜     *d_buff         ç¼“å†²åŒº
  707          //// å‚æ•°è¯´æ˜     len             é•¿åº¦
  708          //// è¿”å›å‚æ•°     void
  709          //// ä½¿ç”¨ç¤ºä¾‹     printf_reverse_order(vstr, vlen);
  710          //// å¤‡æ³¨ä¿¡æ¯     æœ¬å‡½æ•°åœ¨æ–‡ä»¶å†…éƒ¨è°ƒç”¨ ç”¨æˆ·ä¸ç”¨å…³æ³¨ ä¹Ÿä¸å¯ä¿®æ”¹
  711          ////-----------------------------------------------------------------------------------------------------
             ---------------
  712          //static void printf_reverse_order (int8 *d_buff, uint32 len)
  713          //{
  714          //    uint32 i;
  715          //    int8  temp_data;
  716          //    for(i = 0; len / 2 > i; i ++)
  717          //    {
  718          //        temp_data = d_buff[len - 1 - i];
  719          //        d_buff[len - 1 -i ] = d_buff[i];
  720          //        d_buff[i] = temp_data; 
  721          //    }
  722          //}
  723          
  724          ////-----------------------------------------------------------------------------------------------------
             ---------------
  725          //// å‡½æ•°ç®€ä»‹     sprintf å‡½æ•°å®ç°
  726          //// å‚æ•°è¯´æ˜     *buff           ç¼“å†²åŒº
  727          //// å‚æ•°è¯´æ˜     *format         æºå­—ç¬¦ä¸²
  728          //// å‚æ•°è¯´æ˜     ...             å¯å˜å‚æ•°åˆ—è¡¨
  729          //// è¿”å›å‚æ•°     uint32          å¤„ç†åæ•°æ®é•¿
  730          //// ä½¿ç”¨ç¤ºä¾‹     zf_sprintf(buff, "Data : %d", 100);
  731          //// å¤‡æ³¨ä¿¡æ¯     æœ¬å‡½æ•°åœ¨æ–‡ä»¶å†…éƒ¨è°ƒç”¨ ç”¨æˆ·ä¸ç”¨å…³æ³¨ ä¹Ÿä¸å¯ä¿®æ”¹
  732          ////-----------------------------------------------------------------------------------------------------
             ---------------
  733          //uint32 zf_sprintf (int8 *buff, const int8 *format, ...)
  734          //{
  735          //    uint32 buff_len = 0;
  736          //  va_list arg;
  737          //  va_start(arg, format);
  738          
  739          //    while (*format)
  740          //    {
  741          //        int8 ret = *format;
  742          //        if ('%' == ret)
  743          //        {
  744          //            switch (*++ format)
  745          //            {
  746          //                case 'a':// åå…­è¿›åˆ¶pè®¡æ•°æ³•è¾“å‡ºæµ®ç‚¹æ•° æš‚æœªå®ç°
  747          //                    {
  748          //                    }
  749          //                    break;
  750          
  751          //                case 'c':// ä¸€ä¸ªå­—ç¬¦
  752          //                    {
  753          //                        int8 ch = (int8)va_arg(arg, uint32);
  754          //                        *buff = ch;
  755          //                        buff ++;
  756          //                        buff_len ++;
  757          //                    }
  758          //                    break;
C251 COMPILER V5.60.0,  zf_function                                                        10/07/25  21:09:16  PAGE 14  

  759          
  760          //                case 'd':
  761          //                case 'i':// æœ‰ç¬¦å·åè¿›åˆ¶æ•´æ•°
  762          //                    {
  763          //                        int8 vstr[33];
  764          //                        int32 ival = (int32)va_arg(arg, int32);
  765          //                        uint8 vlen = number_conversion_ascii((uint32)ival, vstr, 1, 10);
  766          
  767          //                        if(0 > ival)  
  768          //                        {
  769          //                            vstr[vlen] = '-';
  770          //                            vlen ++;
  771          //                        }
  772          //                        printf_reverse_order(vstr, vlen);
  773          //                        memcpy(buff, vstr, vlen);
  774          //                        buff += vlen;
  775          //                        buff_len += vlen;
  776          //                    }
  777          //                    break;
  778          
  779          //                case 'f':// æµ®ç‚¹æ•°ï¼Œè¾“å‡ºå°æ•°ç‚¹åå…­ä½  ä¸èƒ½æŒ‡å®šè¾“å‡ºç²¾åº¦
  780          //                case 'F':// æµ®ç‚¹æ•°ï¼Œè¾“å‡ºå°æ•°ç‚¹åå…­ä½  ä¸èƒ½æŒ‡å®šè¾“å‡ºç²¾åº¦
  781          //                {
  782          //                    int8 vstr[33];
  783          //                    double ival = (double)va_arg(arg, double);
  784          //                    uint8 vlen = number_conversion_ascii((uint32)(int32)ival, vstr, 1, 10);
  785          
  786          //                    if(0 > ival)  
  787          //                    {
  788          //                        vstr[vlen] = '-';
  789          //                        vlen ++;
  790          //                    }
  791          //                    printf_reverse_order(vstr, vlen);
  792          //                    memcpy(buff, vstr, vlen);
  793          //                    buff += vlen;
  794          //                    buff_len += vlen;
  795          
  796          //                    ival = ((double)ival - (int32)ival)*1000000;
  797          //                    if(ival)
  798          //                    {
  799          //                        vlen = number_conversion_ascii((uint32)(int32)ival, vstr, 1, 10);
  800          //                    }
  801          //                    else
  802          //                    {
  803          //                        vstr[0] = vstr[1] = vstr[2] = vstr[3] = vstr[4] = vstr[5] = '0';
  804          //                        vlen = 6;
  805          //                    }
  806          
  807          //                    while(6 > vlen)
  808          //                    {
  809          //                        vstr[vlen] = '0';
  810          //                        vlen ++;
  811          //                    }
  812          
  813          //                    vstr[vlen] = '.';
  814          //                    vlen ++;
  815          
  816          //                    printf_reverse_order(vstr, vlen);
  817          //                    memcpy(buff, vstr, vlen);
  818          //                    buff += vlen;
  819          //                    buff_len += vlen;
  820          //                }
  821          //                break;
  822          
  823          //                case 'u':// æ— ç¬¦å·åè¿›åˆ¶æ•´æ•°
  824          //                    {
C251 COMPILER V5.60.0,  zf_function                                                        10/07/25  21:09:16  PAGE 15  

  825          //                        int8 vstr[33];
  826          //                        uint32 ival = (uint32)va_arg(arg, uint32);
  827          //                        uint8 vlen = number_conversion_ascii(ival, vstr, 0, 10);
  828          
  829          //                        printf_reverse_order(vstr, vlen);
  830          //                        memcpy(buff, vstr, vlen);
  831          //                        buff += vlen;
  832          //                        buff_len += vlen;
  833          //                    }
  834          //                    break;
  835          
  836          //                case 'o':// æ— ç¬¦å·å…«è¿›åˆ¶æ•´æ•° 
  837          //                    {
  838          //                        int8 vstr[33];
  839          //                        uint32 ival = (uint32)va_arg(arg, uint32);
  840          //                        uint8 vlen = number_conversion_ascii(ival, vstr, 0, 8);
  841          
  842          //                        printf_reverse_order(vstr, vlen);
  843          //                        memcpy(buff, vstr, vlen);
  844          //                        buff += vlen;
  845          //                        buff_len += vlen;
  846          
  847          //                    }
  848          //                    break;
  849          
  850          //                case 'x':// æ— ç¬¦å·åå…­è¿›åˆ¶æ•´æ•°
  851          //                case 'X':// æ— ç¬¦å·åå…­è¿›åˆ¶æ•´æ•°
  852          //                    {
  853          //                        int8 vstr[33];
  854          //                        uint32 ival = (uint32)va_arg(arg, uint32);
  855          //                        uint8 vlen = number_conversion_ascii(ival, vstr, 0, 16);
  856          
  857          //                        printf_reverse_order(vstr, vlen);
  858          //                        memcpy(buff, vstr, vlen);
  859          //                        buff += vlen;
  860          //                        buff_len += vlen;
  861          //                    }
  862          //                    break;
  863          
  864          //                case 's':// å­—ç¬¦ä¸²
  865          //                    {
  866          //                        int8 *pc = va_arg(arg, int8 *);
  867          //                        while (*pc)
  868          //                        {
  869          //                            *buff = *pc;
  870          //                            buff ++;
  871          //                            buff_len ++;
  872          //                            pc ++;
  873          //                        }
  874          //                    }
  875          //                    break;
  876          
  877          //                case 'p':// ä»¥16è¿›åˆ¶å½¢å¼è¾“å‡ºæŒ‡é’ˆ
  878          //                    {
  879          //                        int8 vstr[33];
  880          //                        uint32 ival = (uint32)va_arg(arg, uint32);
  881          //                        //uint8 vlen = number_conversion_ascii(ival, vstr, 0, 16);
  882          //                        number_conversion_ascii(ival, vstr, 0, 16);
  883          //                        printf_reverse_order(vstr, 8);
  884          //                        memcpy(buff, vstr, 8);
  885          //                        buff += 8;
  886          //                        buff_len += 8;
  887          //                    }
  888          //                    break;
  889          
  890          //                case '%':// è¾“å‡ºå­—ç¬¦% 
C251 COMPILER V5.60.0,  zf_function                                                        10/07/25  21:09:16  PAGE 16  

  891          //                    {
  892          //                        *buff = '%';
  893          //                        buff ++;
  894          //                        buff_len ++;
  895          //                    }
  896          //                    break;
  897          
  898          //                default:
  899          //                    break;
  900          //            }
  901          //        }
  902          //        else
  903          //        {
  904          //            *buff = (int8)(*format);
  905          //            buff ++;
  906          //            buff_len ++;
  907          //        }
  908          //        format ++;
  909          //    }
  910          //    va_end(arg);
  911          
  912          //    return buff_len;
  913          //}
  914          
  915          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      5317     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       344     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        16     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
