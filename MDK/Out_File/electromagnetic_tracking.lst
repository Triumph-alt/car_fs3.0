C251 COMPILER V5.60.0,  electromagnetic_tracking                                           19/07/25  22:33:45  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE electromagnetic_tracking
OBJECT MODULE PLACED IN .\Out_File\electromagnetic_tracking.obj
COMPILER INVOKED BY: D:\Software\Keil5\c251v560\C251\BIN\C251.EXE ..\USER\src\electromagnetic_tracking.c LARGE INTR2 WAR
                    -NINGLEVEL(3) OPTIMIZE(0,SPEED) BROWSE INCDIR(..\USER\inc;..\USER\src;..\libraries;..\seekfree_libraries;..\seekfree_peri
                    -pheral) DEBUG PRINT(.\Out_File\electromagnetic_tracking.lst) OBJECT(.\Out_File\electromagnetic_tracking.obj) 

stmt  level    source

    1          #include <STC32G.H>
    2          #include "electromagnetic_tracking.h"
    3          #include "headfile.h"
    4          #include "common.h"
    5          #include "STC32G_DMA.h"    
    6          
    7          u8 xdata DmaAdBuffer[ADC_CH][ADC_DATA];
    8          
    9          // å®šä¹‰å…¨å±€æƒé‡é…ç½®ï¼Œåªä¿ç•™å››ç§åŸºæœ¬å…ƒç´ 
   10          TrackWeights track_weights[4] = {
   11              // æ™®é€šç›´é“
   12          
   13              {0.30f, 0.525, 0.00f, 0.15f, 0.70f, 30, "ç›´é“"},
   14              
   15              // ç›´è§’å¼¯é“
   16              {0.0f, 0.54f, 0.00f, 0.72f, 1.00f, 50, "ç›´è§’å¼¯é“"},
   17              
   18              // åå­—åœ†ç¯
   19              {0.35f, 0.25f, 0.00f, 0.15f, 0.90f, 40, "åå­—åœ†ç¯"},
   20              
   21              // ç¯å²›
   22              {0.35f, 0.45f, 0.00f, 0.15f, 1.00f, 50, "ç¯å²›"}
   23          };
   24          
   25          uint16 adc_fliter_data[SENSOR_COUNT][HISTORY_COUNT] = {0}; //æ»¤æ³¢åçš„å€¼
   26          float result[SENSOR_COUNT] = {0};               //ç”µå­˜å‚¨æ¯ä¸ªç”µæ„Ÿæ»¤æ³¢åçš„æœ€ç»ˆç»“æœå€¼ï¼ˆå°šæœªå½’ä¸€åŒ–ï¼
             -‰ï¼Œæ˜¯è¿æ¥æ»¤æ³¢å¤„ç†å’Œå½’ä¸€åŒ–å¤„ç†çš„ä¸­é—´å˜é‡
   27          uint16 sum[SENSOR_COUNT][HISTORY_COUNT] = {0};          //ç´¯åŠ çš„å’Œ
   28          
   29          // é€’æ¨å‡å€¼æ»¤æ³¢ç›¸å…³å‚æ•°
   30          uint16 times = HISTORY_COUNT;  // æ»¤æ³¢æ¬¡æ•°
   31          uint16 i_num = SENSOR_COUNT;  // ç”µæ„Ÿæ•°é‡
   32          
   33          // å½’ä¸€åŒ–æ•°æ®
   34          float normalized_data[SENSOR_COUNT] = {0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f};  // å½’ä¸€åŒ–åçš„ç”µæ
             -„Ÿæ•°æ®æ•°ç»„
   35          
   36          // å­˜å‚¨æ¯ä¸ªç”µæ„Ÿçš„æœ€å¤§æœ€å°å€¼ï¼Œç”¨äºåŠ¨æ€æ ¡å‡† - æ”¹ä¸ºæ•°ç»„å½¢å¼
   37          // uint16 min_value[SENSOR_COUNT] = {0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF};  // æ¯ä¸ªç
             -”µæ„Ÿçš„æœ€å°å€¼
   38          // uint16 max_value[SENSOR_COUNT] = {0, 0, 0, 0, 0, 0, 0};  // æ¯ä¸ªç”µæ„Ÿçš„æœ€å¤§å€¼
   39          uint16 min_value[SENSOR_COUNT] = {0, 0, 0, 0, 0, 0, 0};  // æ¯ä¸ªç”µæ„Ÿçš„æœ€å°å€¼
   40          uint16 max_value[SENSOR_COUNT] = {2300, 3200, 2800, 2900, 2800, 3100, 2300};  // æ¯ä¸ªç”µæ„Ÿçš„æœ€å¤§å€¼
   41          
   42          // ç”µæ„Ÿä½ç½®è®¡ç®—ç›¸å…³å˜é‡
   43          float signal_strength_value = 0;   // ä¿¡å·å¼ºåº¦æŒ‡æ ‡
   44          int16 position = 0;
   45          float filter_param = 0.4f;   // æ»¤æ³¢ç³»æ•°ï¼Œå¯è°ƒ è¶Šå¤§è¶Šçµæ•
   46          
   47          
   48          // èµ›é“ä¿¡æ¯ç›¸å…³æ ‡å¿—ä½
   49          uint8 track_type = 0;         // èµ›é“ç±»å‹ï¼š0-æ™®é€šï¼Œ1-ç›´è§’å¼¯é“ï¼Œ2-åå­—åœ†ç¯ï¼Œ3-ç¯å²›
   50          uint8 track_type_last = 0;         // èµ›é“ç±»å‹ï¼š0-æ™®é€šï¼Œ1-ç›´è§’å¼¯é“ï¼Œ2-åå­—åœ†ç¯ï¼Œ3-ç¯å²
             -›
   51          
   52          uint8 track_type_zj = 0;          //1-å·¦ç›´è§’ï¼Œ2-å³ç›´è§’
   53          uint8 track_route = 0;            //1-å·¦ç¯ï¼Œ2-å³ç¯
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           19/07/25  22:33:45  PAGE 2   

   54          uint8 track_route_status = 0; //1-å…¥ç¯ï¼Œ2-ç¯ä¸­ï¼Œ3-å‡ºç¯
   55          
   56          uint8 track_ten_flag = 1;       //åå­—åœ†ç¯ï¼š0è¡¨ç¤ºä¸å¯å…¥ç¯ï¼Œ1-å¯ä»¥å…¥ç¯
   57          uint8 ten_ch_flag = 0; //åå­—åœ†ç¯ï¼š1è¡¨ç¤º0.5såtrack_ten_flag=1
   58          uint8 track_island_flag = 1; //ç¯å²›ï¼š0è¡¨ç¤ºä¸å¯å…¥ç¯ï¼Œ1-å¯ä»¥å…¥ç¯
   59          uint8 island_ch_flag = 0; //ç¯å²›ï¼š1è¡¨ç¤º5såtrack_island_flag=1
   60          
   61          uint8 protection_flag = 0;// ç”µç£ä¿æŠ¤é€»è¾‘å˜é‡,0è¡¨ç¤ºæœªä¿æŠ¤ï¼Œ1è¡¨ç¤ºä¿æŠ¤
   62          
   63          uint8 speed_count = 0;
   64          
   65          uint32 power_voltage = 0; //ç”µæºç”µå‹
   66          
   67          //-----------------------------------------------------------------------------
   68          // @brief       é€’æ¨å‡å€¼æ»¤æ³¢
   69          // @param   æ— 
   70          // @return  æ— 
   71          // @author  zp
   72          // Sample usage: average_filter();
   73          //-----------------------------------------------------------------------------
   74          
   75          void average_filter(void)
   76          {
   77   1          uint8 i;
   78   1              static uint16 counter = 0;
   79   1          static const uint8 dma_index_map[SENSOR_COUNT] = {7, 6, 5, 0, 1, 2, 4}; // ç”µæ„Ÿç´¢å¼•ä¸DMAç¼“å†²åŒ
             -ºç´¢å¼•çš„æ˜ å°„å…³ç³»ï¼Œ
   80   1          // ä½¿ç”¨å¾ªç¯ç¼“å†²ç´¢å¼•ä¿å­˜å†å²æ•°æ®
   81   1          static uint8 history_index = 0;                // å½“å‰å†™å…¥çš„å†å²ç´¢å¼•
   82   1          static uint32 running_sum[SENSOR_COUNT] = {0}; // æ¯ä¸ªä¼ æ„Ÿå™¨çš„å†å²å’Œï¼Œç”¨äºå¿«é€Ÿè®¡ç®—å‡
             -å€¼
   83   1      
   84   1          // è¯»å–å®Œæˆï¼Œæ¸…é™¤æ ‡å¿—ä½
   85   1          DmaADCFlag = 0;
   86   1      
   87   1          /* DMAç¼“å†²åŒºä¸ç”µæ„Ÿç´¢å¼•çš„æ˜ å°„å…³ç³»ï¼Œå› ä¸ºDMAç¼“å†²åŒºæ˜¯æŒ‰ADCé€šé“å·ä»å°åˆ°å¤§é¡ºåº
             -å­˜å‚¨çš„
   88   1             SENSOR_HL  -> DmaAdBuffer[7]
   89   1             SENSOR_VL  -> DmaAdBuffer[6]
   90   1             SENSOR_HML -> DmaAdBuffer[5]
   91   1             SENSOR_HC  -> DmaAdBuffer[0]
   92   1             SENSOR_HMR -> DmaAdBuffer[1]
   93   1             SENSOR_VR  -> DmaAdBuffer[2]
   94   1             SENSOR_HR  -> DmaAdBuffer[4]
   95   1          */
   96   1      
   97   1              if (counter < 30)
   98   1              {
   99   2                      counter++;
  100   2              }
  101   1              else
  102   1              {
  103   2                      power_voltage = (uint32)((uint16)DmaAdBuffer[3][2*ADC_TIMES + 2] << 8) |
  104   2                              (uint16)DmaAdBuffer[3][2*ADC_TIMES + 3];
  105   2                      power_voltage = power_voltage * 3630 / 4095;
  106   2                      counter = 0;
  107   2              }
  108   1              
  109   1          for(i = 0; i < SENSOR_COUNT; i++) //é¡ºåºä¸ºHL -> VL -> HML -> HC -> HMR -> VR -> HR
  110   1          {
  111   2              // è¯»å–DMAç¼“å†²åŒºä¸­çš„é«˜ä½å­—èŠ‚ï¼Œç»„åˆæˆ16ä½ADCå¹³å‡å€¼
  112   2              uint8 dma_ch = dma_index_map[i];
  113   2              uint16 value = ((uint16)DmaAdBuffer[dma_ch][2*ADC_TIMES + 2] << 8) |
  114   2                              (uint16)DmaAdBuffer[dma_ch][2*ADC_TIMES + 3];
  115   2      
  116   2              // æ›´æ–°é€’æ¨å’Œï¼šç§»é™¤æ—§å€¼ï¼ŒåŠ å…¥æ–°å€¼
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           19/07/25  22:33:45  PAGE 3   

  117   2              running_sum[i] -= adc_fliter_data[i][history_index];
  118   2              adc_fliter_data[i][history_index] = value;
  119   2              running_sum[i] += value;
  120   2      
  121   2              // è®¡ç®—å‡å€¼å¹¶å­˜å…¥ç»“æœæ•°ç»„
  122   2              result[i] = (float)running_sum[i] / (float)times;
  123   2          }
  124   1      
  125   1          // æ›´æ–°å¾ªç¯ç¼“å†²ç´¢å¼•
  126   1          history_index++;
  127   1          if(history_index >= times) history_index = 0;
  128   1      }
  129                  
  130          
  131          //-----------------------------------------------------------------------------
  132          // @brief       ä¸­ä½å€¼æ»¤æ³¢ï¼Œå°†æ¯ä¸ªç”µæ„Ÿçš„ä¸­ä½æ•°ä½œä¸ºç»“æœ
  133          // @param   æ— 
  134          // @return  æ— 
  135          // @author  ZP
  136          // Sample usage: mid_filter();
  137          //-----------------------------------------------------------------------------
  138          static uint8 mid_initialized = 0;  // ä¸­ä½å€¼æ»¤æ³¢åˆå§‹åŒ–æ ‡å¿—
  139          static uint16 sample_count = 0;    // é‡‡æ ·è®¡æ•°å™¨
  140          
  141          void mid_filter(void)
  142          {
  143   1          uint16 temp = 0, a = 0, t = 0;
  144   1          uint16 mid_index = 0;  //ä¸­ä½æ•°
  145   1              uint16 i = 0; //ç”¨äºå¾ªç¯
  146   1          // åˆ›å»ºä¸´æ—¶æ•°ç»„ç”¨äºæ’åºï¼Œé¿å…ä¿®æ”¹åŸå§‹æ•°æ®
  147   1          uint16 sort_array[HISTORY_COUNT];  // ä½¿ç”¨å®å®šä¹‰çš„å¸¸é‡è€Œä¸æ˜¯å˜é‡
  148   1              
  149   1          // è°ƒç”¨å‡å€¼æ»¤æ³¢è·å–æ–°çš„é‡‡æ ·å€¼
  150   1          average_filter();
  151   1          
  152   1          // å¦‚æœå°šæœªåˆå§‹åŒ–å®Œæˆ
  153   1          if (!mid_initialized)
  154   1          {
  155   2              // å°†å½“å‰æ»¤æ³¢ç»“æœå­˜å…¥å†å²æ•°ç»„
  156   2              for(a = 0; a < i_num; a++)
  157   2              {
  158   3                  adc_fliter_data[a][sample_count] = adc_fliter_data[a][0];
  159   3                  result[a] = adc_fliter_data[a][0];
  160   3              }
  161   2              
  162   2              sample_count++;
  163   2              
  164   2              // å½“é‡‡é›†åˆ°è¶³å¤Ÿæ ·æœ¬æ—¶ï¼Œæ ‡è®°åˆå§‹åŒ–å®Œæˆ
  165   2              if (sample_count >= times)
  166   2              {
  167   3                  mid_initialized = 1;
  168   3                  sample_count = 0;  // é‡ç½®è®¡æ•°å™¨ç”¨äºå¾ªç¯ç¼“å†²
  169   3              }
  170   2          }
  171   1          else  // å·²åˆå§‹åŒ–ï¼Œæ‰§è¡Œä¸­ä½å€¼æ»¤æ³¢
  172   1          {
  173   2              // æ›´æ–°å†å²æ•°æ®æ•°ç»„
  174   2              for(a = 0; a < i_num; a++)
  175   2              {
  176   3                  adc_fliter_data[a][sample_count] = adc_fliter_data[a][0];
  177   3              }
  178   2              
  179   2              // æ›´æ–°å¾ªç¯ç¼“å†²åŒºç´¢å¼•
  180   2              sample_count = (sample_count + 1) % times;
  181   2              
  182   2              // å¯¹æ¯ä¸ªç”µæ„Ÿé€šé“è¿›è¡Œå¤„ç†
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           19/07/25  22:33:45  PAGE 4   

  183   2              for(a = 0; a < i_num; a++)
  184   2              {
  185   3                  for(t = 0; t < times; t++)
  186   3                  {
  187   4                      sort_array[t] = adc_fliter_data[a][t];
  188   4                  }
  189   3                  
  190   3                  // å†’æ³¡æ’åº
  191   3                  for(i = 0; i < times-1; i++)
  192   3                  {
  193   4                      for(t = 0; t < times-i-1; t++)
  194   4                      {
  195   5                          if(sort_array[t] > sort_array[t+1])
  196   5                          {
  197   6                              temp = sort_array[t];
  198   6                              sort_array[t] = sort_array[t+1];
  199   6                              sort_array[t+1] = temp;
  200   6                          }
  201   5                      }
  202   4                  }
  203   3                  
  204   3                  // è®¡ç®—ä¸­ä½æ•°ç´¢å¼•
  205   3                  mid_index = times / 2;  // 5 / 2 = 2  ,sort_array[2]æ˜¯ç¬¬ä¸‰ä¸ªæ•°å³ä¸­ä½æ•°
  206   3                  
  207   3                  // å–ä¸­ä½æ•°ä½œä¸ºç»“æœ
  208   3                  result[a] = sort_array[mid_index];
  209   3              }
  210   2          }
  211   1      }
  212          
  213          
  214          //-----------------------------------------------------------------------------
  215          // @brief       æ›´æ–°æ¯ä¸ªç”µæ„Ÿçš„æœ€å¤§æœ€å°å€¼ï¼Œç”¨äºåŠ¨æ€æ ¡å‡†
  216          // @param   æ— 
  217          // @return  æ— 
  218          // @author  ZP
  219          // Sample usage: update_min_max_values();
  220          //-----------------------------------------------------------------------------
  221          //void update_min_max_values(void)
  222          //{
  223          //    uint8 i;
  224          //    static uint16 update_counter = 0;
  225          //    
  226          //    // å®šæœŸè½»å¾®è¡°å‡æœ€å¤§æœ€å°å€¼ï¼Œä½¿ç³»ç»Ÿèƒ½é€‚åº”ç¯å¢ƒå˜åŒ–
  227          //    update_counter++;
  228          //    if(update_counter >= 1000)  // æ¯1000æ¬¡è°ƒç”¨æ‰§è¡Œä¸€æ¬¡è¡°å‡
  229          //    {
  230          //        update_counter = 0;
  231          //        
  232          //        // æœ€å°å€¼ç•¥å¾®å¢åŠ ï¼Œæœ€å¤§å€¼ç•¥å¾®å‡å°‘ï¼Œå½¢æˆç¼“æ…¢è¡°å‡
  233          //        for(i = 0; i < SENSOR_COUNT; i++)
  234          //        {
  235          //            // æœ€å°å€¼å‘ä¸Šè¡°å‡ï¼ˆå¢åŠ 1%ï¼‰
  236          //            min_value[i] += min_value[i] / 100;
  237          //            
  238          //            // æœ€å¤§å€¼å‘ä¸‹è¡°å‡ï¼ˆå‡å°‘1%ï¼‰
  239          //            if(max_value[i] > min_value[i])  // ç¡®ä¿æœ€å¤§å€¼å§‹ç»ˆå¤§äºæœ€å°å€¼
  240          //                max_value[i] -= max_value[i] / 100;
  241          //        }
  242          //    }
  243          //    
  244          //    // æ›´æ–°æ¯ä¸ªç”µæ„Ÿçš„æœ€å°å€¼å’Œæœ€å¤§å€¼
  245          //    for(i = 0; i < SENSOR_COUNT; i++)
  246          //    {
  247          //        // å¼‚å¸¸å€¼æ£€æµ‹ - å¦‚æœè¯»æ•°å¼‚å¸¸å¤§æˆ–å¼‚å¸¸å°ï¼Œå¯èƒ½æ˜¯ä¼ æ„Ÿå™¨æ•…éšœï¼Œä¸æ›´æ–°
  248          //        if(result[i] > 1000 || result[i] < 5)
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           19/07/25  22:33:45  PAGE 5   

  249          //            continue;
  250          //            
  251          //        // æ›´æ–°æœ€å°å€¼ï¼ˆå¿½ç•¥è¿‡å°çš„å€¼ï¼Œå¯èƒ½æ˜¯å™ªå£°ï¼‰
  252          //        if(result[i] < min_value[i] && result[i] > 10) 
  253          //            min_value[i] = result[i];
  254          //        
  255          //        // æ›´æ–°æœ€å¤§å€¼
  256          //        if(result[i] > max_value[i]) 
  257          //            max_value[i] = result[i];
  258          //    }
  259          //    
  260          //    // ç¡®ä¿æœ€å¤§æœ€å°å€¼ä¹‹é—´æœ‰è¶³å¤Ÿå·®è·ï¼Œé¿å…é™¤ä»¥æ¥è¿‘0çš„å€¼
  261          //    for(i = 0; i < SENSOR_COUNT; i++)
  262          //    {
  263          //        if(max_value[i] - min_value[i] < 20)
  264          //        {
  265          //            // å¦‚æœå·®è·å¤ªå°ï¼Œå¼ºåˆ¶è®¾ç½®ä¸€ä¸ªåˆç†å·®è·
  266          //            max_value[i] = min_value[i] + 20;
  267          //        }
  268          //    }
  269          //}
  270          
  271          //-----------------------------------------------------------------------------
  272          // @brief       å½’ä¸€åŒ–ç”µæ„Ÿæ•°æ®
  273          // @param   æ— 
  274          // @return  æ— 
  275          // @author  ZP
  276          // Sample usage: normalize_sensors();
  277          //-----------------------------------------------------------------------------
  278          void normalize_sensors(void)
  279          {
  280   1          uint8 i;
  281   1          // å¯é€‰ï¼šå¯¹å½’ä¸€åŒ–åçš„æ•°æ®è¿›è¡Œå¹³æ»‘å¤„ç†ï¼Œå‡å°‘æŠ–åŠ¨
  282   1          static float last_normalized[SENSOR_COUNT] = {0};
  283   1          // å¹³æ»‘å› å­ï¼Œå¯è°ƒæ•´ï¼šå€¼è¶Šå¤§ï¼Œå“åº”è¶Šå¿«ä½†æŠ–åŠ¨è¶Šæ˜æ˜¾ï¼Œå€¼è¶Šå°ï¼Œå“åº”è¶Šæ…¢ä½
             -†æ›´å¹³ç¨³
  284   1          float smooth_factor = 0.7f; // å»ºè®®åœ¨0.6-0.8èŒƒå›´å†…è°ƒæ•´ï¼Œæ ¹æ®å°è½¦å®é™…è¡¨ç°å¾®è°ƒ    //
             - é¦–å…ˆæ›´æ–°æœ€å¤§æœ€å°å€¼
  285   1          
  286   1          // å¯¹æ¯ä¸ªç”µæ„Ÿè¿›è¡Œå½’ä¸€åŒ–å¤„ç†
  287   1          for(i = 0; i < SENSOR_COUNT; i++)
  288   1          {
  289   2              // æ£€æŸ¥æœ€å¤§å€¼æ˜¯å¦è¶³å¤Ÿå¤§ï¼Œé˜²æ­¢é™¤ä»¥æ¥è¿‘0çš„å€¼
  290   2              if(max_value[i] > 10) 
  291   2              {
  292   3                  // æ ‡å‡†çº¿æ€§å½’ä¸€åŒ–ï¼Œå°†å€¼æ˜ å°„åˆ°0-100èŒƒå›´ï¼ˆä¹˜ä»¥100æ–¹ä¾¿åç»­ä½¿ç”¨ï¼‰
  293   3                  normalized_data[i] = (float)(result[i] - min_value[i]) * 100.0f / (max_value[i] - min_value[i
             -]);
  294   3                  
  295   3                  // å¯é€‰ï¼šä½¿ç”¨å¹³æ–¹æ ¹éçº¿æ€§æ˜ å°„ï¼Œå¢å¼ºå°ä¿¡å·å“åº”(å¦‚æœå‘ç°å°è½¦å¯¹å°å
             -å·®ååº”ä¸æ•æ„Ÿï¼Œå¯ä»¥å–æ¶ˆå¹³æ–¹æ ¹æ˜ å°„çš„æ³¨é‡Š)
  296   3                  // normalized_data[i] = sqrtf(normalized_data[i] / 100.0f) * 100.0f;
  297   3              }
  298   2              else 
  299   2              {
  300   3                  // å¦‚æœæœ€å¤§æœ€å°å€¼å·®å¼‚å¤ªå°ï¼Œå¯èƒ½æ˜¯ä¼ æ„Ÿå™¨æ•…éšœæˆ–æœªæ­£ç¡®åˆå§‹åŒ–
  301   3                  // ä½¿ç”¨åŸå§‹å€¼çš„ç›¸å¯¹æ¯”ä¾‹ä½œä¸ºæ›¿ä»£ï¼Œä¹Ÿä¹˜ä»¥100ä¿æŒä¸€è‡´æ€§
  302   3                  normalized_data[i] = (float)result[i] / 30.0f;  // å‡è®¾ADCæœ€å¤§å€¼ä¸º1000ï¼Œå½’ä¸€åŒ–åˆ°0-
             -100
  303   3              }
  304   2              
  305   2              // é™åˆ¶èŒƒå›´åœ¨0-100ä¹‹é—´
  306   2              if(normalized_data[i] > 100.0f) normalized_data[i] = 100.0f;
  307   2              if(normalized_data[i] < 0.0f) normalized_data[i] = 0.0f;
  308   2          }
  309   1          
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           19/07/25  22:33:45  PAGE 6   

  310   1          for(i = 0; i < SENSOR_COUNT; i++)
  311   1          {
  312   2              // ä½é€šæ»¤æ³¢å¹³æ»‘å¤„ç†
  313   2              normalized_data[i] = normalized_data[i] * smooth_factor + 
  314   2                                  last_normalized[i] * (1.0f - smooth_factor);
  315   2              
  316   2              // ä¿å­˜å½“å‰å€¼ç”¨äºä¸‹æ¬¡å¹³æ»‘
  317   2              last_normalized[i] = normalized_data[i];
  318   2          }
  319   1      }
  320          
  321          //-----------------------------------------------------------------------------
  322          // @brief       æ”¹è¿›ç‰ˆè®¡ç®—ä½ç½®ï¼ˆä½¿ç”¨è‡ªé€‚åº”å·®æ¯”å’ŒåŠ æƒæ–¹æ³•ï¼‰
  323          // @param   æ— 
  324          // @return  è®¡ç®—å¾—åˆ°çš„ä½ç½®å€¼ï¼ŒèŒƒå›´-100åˆ°100
  325          // @author  ZP
  326          // Sample usage: position = calculate_position_improved();
  327          //-----------------------------------------------------------------------------
  328          int16 calculate_position_improved(void)
  329          {
  330   1          // åœ¨å‡½æ•°å¼€å§‹å¤„å£°æ˜æ‰€æœ‰å˜é‡
  331   1          float weight_outer = 0.15f;   // å¤–ä¾§ç”µæ„Ÿæƒé‡(HLå’ŒHR)
  332   1          float weight_middle = 0.40f;  // ä¸­é—´ç”µæ„Ÿæƒé‡(HMLå’ŒHMR)
  333   1          float weight_vertical = 0.15f; // çºµå‘ç”µæ„Ÿæƒé‡(VLå’ŒVR)
  334   1          float weight_center = 0.0f;  // ä¸­å¿ƒç”µæ„Ÿæƒé‡(HC)(æ²¡ç”¨ä¸Š)
  335   1          
  336   1          float diff_outer = 0;        // å¤–ä¾§ç”µæ„Ÿå·®å€¼
  337   1          float diff_middle = 0;       // ä¸­é—´ç”µæ„Ÿå·®å€¼
  338   1          float diff_vertical = 0;     // çºµå‘ç”µæ„Ÿå·®å€¼
  339   1          
  340   1          float sum_outer = 0;         // å¤–ä¾§ç”µæ„Ÿå’Œå€¼
  341   1          float sum_middle = 0;        // ä¸­é—´ç”µæ„Ÿå’Œå€¼
  342   1          float sum_vertical = 0;      // çºµå‘ç”µæ„Ÿå’Œå€¼
  343   1          float center_value = 0;      // ä¸­é—´ç”µæ„Ÿå€¼
  344   1          
  345   1          float ratio_outer = 0;       // å¤–ä¾§ç”µæ„Ÿå·®æ¯”å’Œ
  346   1          float ratio_middle = 0;      // ä¸­é—´ç”µæ„Ÿå·®æ¯”å’Œ
  347   1          float ratio_vertical = 0;    // çºµå‘ç”µæ„Ÿå·®æ¯”å’Œ
  348   1          
  349   1          float signal_strength = 0;   // ä¿¡å·å¼ºåº¦æŒ‡æ ‡
  350   1          static int16 last_pos = 0;   // ä¸Šä¸€æ¬¡ä½ç½®å€¼ï¼Œç”¨äºæ»¤æ³¢
  351   1          static int16 very_last_pos = 0;  // ä¸Šä¸Šæ¬¡ä½ç½®å€¼ï¼Œç”¨äºäºŒæ¬¡æ»¤æ³¢
  352   1      //    static int16 very_very_last_pos = 0;  // ä¸Šä¸Šä¸Šæ¬¡ä½ç½®å€¼ï¼Œç”¨äºä¸‰æ¬¡æ»¤æ³¢
  353   1          int16 pos = 0;               // å½“å‰è®¡ç®—å¾—åˆ°çš„ä½ç½®å€¼
  354   1          static int16 max_change_rate = 2; // å…è®¸çš„æœ€å¤§å˜åŒ–ç‡ï¼Œè¶Šå¤§è¶Šçµæ•
  355   1          int16 position_change = 0;   // ä½ç½®å˜åŒ–é‡
  356   1              
  357   1              
  358   1              
  359   1              
  360   1              
  361   1              // ä½ç½®è®¡ç®—ï¼ˆåŒ…å«ä¸­å¿ƒç”µæ„Ÿçš„è´¡çŒ®ï¼‰
  362   1          // ä¸­å¿ƒç”µæ„Ÿè¶Šå¤§ï¼Œä½ç½®è¶Šæ¥è¿‘ä¸­å¿ƒçº¿ï¼Œè¿™é‡Œç›´æ¥å°†ä¸­å¿ƒç”µæ„Ÿä½œä¸ºä½ç½®ä¿®æ­£å› å­
             -
  363   1          float center_correction = 0;
  364   1          
  365   1          // è®¡ç®—å„å¯¹ç”µæ„Ÿçš„å·®å€¼å’Œå’Œå€¼
  366   1          diff_outer = normalized_data[SENSOR_HL] - normalized_data[SENSOR_HR];
  367   1          sum_outer = normalized_data[SENSOR_HL] + normalized_data[SENSOR_HR];
  368   1          
  369   1          diff_middle = normalized_data[SENSOR_HML] - normalized_data[SENSOR_HMR];
  370   1          sum_middle = normalized_data[SENSOR_HML] + normalized_data[SENSOR_HMR];
  371   1          
  372   1          diff_vertical = normalized_data[SENSOR_VL] - normalized_data[SENSOR_VR];
  373   1          sum_vertical = normalized_data[SENSOR_VL] + normalized_data[SENSOR_VR];
  374   1          
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           19/07/25  22:33:45  PAGE 7   

  375   1          // è·å–ä¸­é—´ç”µæ„Ÿå€¼
  376   1          center_value = normalized_data[SENSOR_HC];
  377   1          
  378   1          // è®¡ç®—ä¿¡å·å¼ºåº¦æŒ‡æ ‡ - æ‰€æœ‰ç”µæ„Ÿå¹³å‡å€¼
  379   1          signal_strength = (sum_outer + sum_middle + sum_vertical + center_value) / 7.0f;
  380   1          signal_strength_value = signal_strength; // ä¿å­˜ä¿¡å·å¼ºåº¦æŒ‡æ ‡
  381   1      
  382   1      
  383   1      
  384   1      
  385   1          // è®¡ç®—å·®æ¯”å’Œï¼Œä½¿ç”¨å¹³æ»‘è¿‡æ¸¡å‡½æ•°ä»£æ›¿ç¡¬é˜ˆå€¼ï¼Œé¿å…åœ¨ä¸´ç•Œå€¼é™„è¿‘äº§ç”Ÿè·³å˜
  386   1          // å¤–ä¾§ç”µæ„Ÿå¹³æ»‘è¿‡æ¸¡
  387   1          if(sum_outer > 16.0f)
  388   1              ratio_outer = diff_outer / sum_outer;
  389   1          else if(sum_outer < 3.0f)
  390   1              ratio_outer = 0;
  391   1          else
  392   1              ratio_outer = (diff_outer / sum_outer) * (sum_outer - 3.0f) / 7.0f; // 5-12èŒƒå›´å†…çº¿æ€§è¿‡æ¸¡
  393   1              
  394   1          // ä¸­é—´ç”µæ„Ÿå¹³æ»‘è¿‡æ¸¡
  395   1          if(sum_middle > 16.0f)
  396   1              ratio_middle = diff_middle / sum_middle;
  397   1          else if(sum_middle < 3.0f)
  398   1              ratio_middle = 0;
  399   1          else
  400   1              ratio_middle = (diff_middle / sum_middle) * (sum_middle - 3.0f) / 7.0f; // 5-12èŒƒå›´å†…çº¿æ€§è¿‡
             -æ¸¡
  401   1          
  402   1          // çºµå‘ç”µæ„Ÿå¹³æ»‘è¿‡æ¸¡
  403   1          if(sum_vertical > 16.0f)
  404   1              ratio_vertical = diff_vertical / sum_vertical;
  405   1          else if(sum_vertical < 3.0f)
  406   1              ratio_vertical = 0;
  407   1          else
  408   1              ratio_vertical = (diff_vertical / sum_vertical) * (sum_vertical - 3.0f) / 7.0f; // 5-12èŒƒå›´å†…ç
             -º¿æ€§è¿‡æ¸¡
  409   1          
  410   1              
  411   1              
  412   1              
  413   1          // èµ›é“ç±»å‹è¯†åˆ« - æ ¹æ®ä¸ƒç”µæ„Ÿç‰¹å¾åˆ¤æ–­
  414   1          if (track_type == WEIGHT_STRAIGHT || track_type == 4) // 0. å½“å‰è®¤ä¸ºæ˜¯æ™®é€šèµ›é“æ—¶ï¼Œå°è¯•åˆ
             -¤æ–­ç‰¹æ®Šèµ›é“
  415   1          {    
  416   2              // 1. ç›´è§’å¼¯é“ç‰¹å¾
  417   2              if(((normalized_data[SENSOR_VL] > 55.0f && normalized_data[SENSOR_VR] < 25.0f) || //å·¦è½¬
  418   2                      (normalized_data[SENSOR_VR] > 65.0f && normalized_data[SENSOR_VL] < 20.0f)) &&  //å³è½¬
  419   2                                                                      normalized_data[SENSOR_HC] < 70.0f && 
  420   2                      signal_strength > 25.0f && signal_strength < 50.0f) // è°ƒæ•´ä¿¡å·å¼ºåº¦èŒƒå›´
  421   2              {
  422   3                  track_type = WEIGHT_RIGHT_ANGLE; // ç›´è§’å¼¯é“
  423   3              }
  424   2              // else if (((normalized_data[SENSOR_HC] > 60.0f && normalized_data[SENSOR_HMR] > 88.0f && normal
             -ized_data[SENSOR_VL] > 50.0f && normalized_data[SENSOR_VR] > 75.0f) ||  //é€†æ—¶é’ˆ
  425   2              // (normalized_data[SENSOR_HC] > 80.0f && normalized_data[SENSOR_HML] > 80.0f && normalized_data[
             -SENSOR_HMR] < 45.0f && normalized_data[SENSOR_VL] > 75.0f && normalized_data[SENSOR_VR] > 45.0f)) && 
  426   2              // track_ten_flag == 1 && signal_strength > 50.0f ) 
  427   2              // {
  428   2              //     track_type = 2; //åå­—åœ†ç¯
  429   2              //     track_ten_flag = 0; 
  430   2              //     ten_ch_flag = 1;//æ„Ÿåº”åˆ°å…¥ç¯ï¼Œå»¶æ—¶2så†è®©track_ten_flag=1
  431   2                                      
  432   2              // }
  433   2              else if(normalized_data[SENSOR_HC] > 90.0f && (((normalized_data[SENSOR_HR] + normalized_data[SEN
             -SOR_VR]) - (normalized_data[SENSOR_HL] + normalized_data[SENSOR_VL]) > 90.0f && normalized_data[SENSOR_VL] < 20.0f)||  /
             -/å³ç¯å²›
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           19/07/25  22:33:45  PAGE 8   

  434   2                                      ((normalized_data[SENSOR_HL] + normalized_data[SENSOR_VL]) - (normalized_data[SENSOR_HR] + normalized
             -_data[SENSOR_VR]) > 90.0f && normalized_data[SENSOR_VR] < 20.0f))  //å·¦ç¯å²›(æ¶ˆé™¤åå­—è¯¯åˆ¤)
  435   2                       && signal_strength > 50.0f && track_island_flag == 1 )    
  436   2              {
  437   3                  track_type = WEIGHT_ROUNDABOUT;// ç¯å²›
  438   3                  track_island_flag = 0; //5såæ‰å¯ä»¥é‡æ–°åˆ¤æ–­å…¥ç¯
  439   3                  island_ch_flag = 1; //å¼€å§‹è®¡æ—¶5s
  440   3              }
  441   2          }
  442   1          else if (track_type == WEIGHT_RIGHT_ANGLE) // 1. ç›´è§’å¼¯é“
  443   1              {
  444   2                      if (normalized_data[SENSOR_VL] > 50.0f && normalized_data[SENSOR_VR] < 35.0f )
  445   2                      {
  446   3                              track_type_zj = 1; //å·¦è½¬
  447   3                      }
  448   2                      else if (normalized_data[SENSOR_VR] > 50.0f && normalized_data[SENSOR_VL] < 35.0f )
  449   2                      {
  450   3                              track_type_zj = 2; //å³è½¬
  451   3                      }   
  452   2                      
  453   2                      if (track_type_zj != 0)
  454   2                      {
  455   3                              // å›åˆ°ç›´é“ - å¯é€‰:å¢åŠ  signal_strength < 45.0f åˆ¤æ–­
  456   3                  if (track_type_zj == 1 && (normalized_data[SENSOR_HC] > 65.0f && normalized_data[SENSOR_VL] <
             - 50.0f ))
  457   3                  {
  458   4                      track_type = WEIGHT_STRAIGHT; 
  459   4                      track_type_zj = 0;
  460   4                  }
  461   3                  else if (track_type_zj == 2 && (normalized_data[SENSOR_HC] > 65.0f && normalized_data[SENSOR_
             -VR] < 50.0f ))
  462   3                  {
  463   4                      track_type = WEIGHT_STRAIGHT; 
  464   4                      track_type_zj = 0;
  465   4                  }
  466   3      //                      if (signal_strength > 50) // ç›´è§’å³æ‹è¿›åœ†ç¯çš„ç‰¹æ®Šç‚¹
  467   3      //                      {
  468   3      //                              track_type = WEIGHT_ROUNDABOUT; 
  469   3      //                              // track_type_zj = 0;
  470   3      //                          // weight_outer = 0.4;  // æ¢æˆç›´é“çš„æƒ
  471   3      //                          // weight_middle = 0.1;
  472   3      //                          // weight_vertical = 0.1;
  473   3      //                          // filter_param = track_weights[WEIGHT_STRAIGHT].filter_param;
  474   3      //                          // max_change_rate = track_weights[WEIGHT_STRAIGHT].max_change_rate;
  475   3      //                      }
  476   3                      }
  477   2              }
  478   1          else if (track_type == WEIGHT_CROSS) // 2. åå­—åœ†ç¯
  479   1          {
  480   2                      // å‡ºç¯  
  481   2                      if (((normalized_data[SENSOR_HC] > 70.0f && normalized_data[SENSOR_HML] > 75.0f && normalized_data[SENS
             -OR_VL] > 80.0f && normalized_data[SENSOR_VR] > 70.0f)  || //é€†æ—¶é’ˆ
  482   2                                               (normalized_data[SENSOR_HC] > 80.0f && normalized_data[SENSOR_HMR] > 80.0f && normalized_data[SENSO
             -R_VL] > 70.0f && normalized_data[SENSOR_VR] > 80.0f )) &&
  483   2                                                      track_ten_flag == 1 && signal_strength > 50.0f )  //é¡ºæ—¶é’ˆ
  484   2                       {
  485   3                              track_type = WEIGHT_STRAIGHT; //å›ç›´é“
  486   3                              track_ten_flag = 0;
  487   3                              ten_ch_flag = 1; //æ„Ÿåº”åˆ°å‡ºç¯å»¶æ—¶2så†è®©track_ten_flag=1        
  488   3                       }
  489   2              }
  490   1          else if (track_type == WEIGHT_ROUNDABOUT) // 3. ç¯å²›   
  491   1          {           
  492   2              if(normalized_data[SENSOR_HR] > 70.0f && track_route == 0)
  493   2              {
  494   3                  // å³ç¯å²›
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           19/07/25  22:33:45  PAGE 9   

  495   3                  track_route = 2;
  496   3                              track_route_status = 1;
  497   3              }
  498   2               else if( normalized_data[SENSOR_HL] > 70.0f && track_route == 0)
  499   2               {
  500   3                   // å·¦ç¯å²›
  501   3                   track_route = 1;
  502   3                               track_route_status = 1;
  503   3               }
  504   2                      if(track_route_status == 2 && ((normalized_data[SENSOR_VL] > 60.0f && normalized_data[SENSOR_HL] > 70.0
             -f)|| 
  505   2              (normalized_data[SENSOR_VR] > 50.0f && normalized_data[SENSOR_HR] > 50.0f)))
  506   2                      {
  507   3      //                      track_route = 0;
  508   3                              track_route_status = 3;
  509   3      //                      P26 = 0;
  510   3      //                      track_type == WEIGHT_RIGHT_ANGLE; // æ£€éªŒä½ç‚¹
  511   3                      }
  512   2          }
  513   1      
  514   1          // 4. è¶…å‡ºç½®0
  515   1      //   if(normalized_data[SENSOR_HC] < 2.0f && normalized_data[SENSOR_HMR] < 2.0f && normalized_data[SENSOR
             -_HML] < 2.0f)
  516   1      //   {
  517   1      //       track_type = WEIGHT_STRAIGHT;
  518   1      //       track_route = 0;
  519   1      //       track_route_status = 0;
  520   1      //         track_type_zj = 0;
  521   1      //   }
  522   1          
  523   1          // æ ¹æ®èµ›é“ç±»å‹å’Œä¿¡å·å¼ºåº¦è°ƒæ•´æƒé‡
  524   1         switch(track_type)
  525   1         {
  526   2             case WEIGHT_STRAIGHT: // æ™®é€šèµ›é“
  527   2                 // ä½¿ç”¨ç›´é“æƒé‡
  528   2                 weight_outer = track_weights[WEIGHT_STRAIGHT].weight_outer;
  529   2                 weight_middle = track_weights[WEIGHT_STRAIGHT].weight_middle;
  530   2                 weight_vertical = track_weights[WEIGHT_STRAIGHT].weight_vertical;
  531   2                 filter_param = track_weights[WEIGHT_STRAIGHT].filter_param;
  532   2                 max_change_rate = track_weights[WEIGHT_STRAIGHT].max_change_rate;
  533   2                 break;
  534   2                 
  535   2             case WEIGHT_RIGHT_ANGLE: // ç›´è§’å¼¯é“
  536   2                 // ä½¿ç”¨ç›´è§’å¼¯é“æƒé‡
  537   2                 weight_outer = track_weights[WEIGHT_RIGHT_ANGLE].weight_outer;
  538   2                 weight_middle = track_weights[WEIGHT_RIGHT_ANGLE].weight_middle;
  539   2                 weight_vertical = track_weights[WEIGHT_RIGHT_ANGLE].weight_vertical;
  540   2                 filter_param = track_weights[WEIGHT_RIGHT_ANGLE].filter_param;
  541   2                 max_change_rate = track_weights[WEIGHT_RIGHT_ANGLE].max_change_rate;
  542   2                 break;
  543   2                 
  544   2             case WEIGHT_CROSS: // åå­—åœ†ç¯
  545   2                 // ä½¿ç”¨åå­—åœ†ç¯æƒé‡
  546   2                 weight_outer = track_weights[WEIGHT_CROSS].weight_outer;
  547   2                 weight_middle = track_weights[WEIGHT_CROSS].weight_middle;
  548   2                 weight_vertical = track_weights[WEIGHT_CROSS].weight_vertical;
  549   2                 filter_param = track_weights[WEIGHT_CROSS].filter_param;
  550   2                 max_change_rate = track_weights[WEIGHT_CROSS].max_change_rate;
  551   2                 break;
  552   2                 
  553   2             case WEIGHT_ROUNDABOUT: // ç¯å²›
  554   2                 // ä½¿ç”¨ç¯å²›æƒé‡
  555   2                 weight_outer = track_weights[WEIGHT_ROUNDABOUT].weight_outer;
  556   2                 weight_middle = track_weights[WEIGHT_ROUNDABOUT].weight_middle;
  557   2                 weight_vertical = track_weights[WEIGHT_ROUNDABOUT].weight_vertical;
  558   2                 filter_param = track_weights[WEIGHT_ROUNDABOUT].filter_param;
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           19/07/25  22:33:45  PAGE 10  

  559   2                 max_change_rate = track_weights[WEIGHT_ROUNDABOUT].max_change_rate;
  560   2                 break;
  561   2             default:
  562   2                 // ä½¿ç”¨é»˜è®¤çš„ç›´é“æƒé‡
  563   2                 weight_outer = track_weights[WEIGHT_STRAIGHT].weight_outer;
  564   2                 weight_middle = track_weights[WEIGHT_STRAIGHT].weight_middle;
  565   2                 weight_vertical = track_weights[WEIGHT_STRAIGHT].weight_vertical;
  566   2                 filter_param = track_weights[WEIGHT_STRAIGHT].filter_param;
  567   2                 max_change_rate = track_weights[WEIGHT_STRAIGHT].max_change_rate;
  568   2                 break;
  569   2         }
  570   1          
  571   1          // ç‰¹æ®Šæƒ…å†µå¤„ç†ï¼šå½“æ‰€æœ‰ç”µæ„Ÿå€¼éƒ½å¾ˆå°æ—¶ï¼Œå¯èƒ½å·²ç»åç¦»èµ›é“
  572   1          if(sum_outer < 10.0f && sum_middle < 10.0f && sum_vertical < 10.0f && center_value < 10.0f)
  573   1          {
  574   2      //        if(last_pos > 0)
  575   2      //            return (last_pos + 10);  // å‘å³åç¦»
  576   2      //        else
  577   2      //            return (last_pos - 10); // å‘å·¦åç¦»
  578   2                      
  579   2                      return last_pos;
  580   2          }
  581   1          
  582   1          // å½“ä¸­å¿ƒç”µæ„Ÿå¤§äºé˜ˆå€¼æ—¶ï¼Œè®¤ä¸ºè½¦è¾†æ¥è¿‘ä¸­å¿ƒï¼Œå¯¹ä½ç½®è¿›è¡Œä¿®æ­£
  583   1          if(center_value > 90.0f) {
  584   2              // ä¿®æ­£ç³»æ•°ï¼Œå½“ä¸­å¿ƒç”µæ„Ÿå¼ºåº¦é«˜æ—¶ï¼Œä¿®æ­£ç³»æ•°å¤§
  585   2              center_correction = (center_value - 90.0f) / 10.0f * 0.2f;  // æœ€å¤§ä¿®æ­£50%
  586   2          }
  587   1          
  588   1          // ä¸‰ç»„å·®æ¯”å’ŒåŠ æƒå¹³å‡è®¡ç®—ä½ç½®
  589   1          pos = (int16)((ratio_outer * weight_outer + 
  590   1                         ratio_middle * weight_middle + 
  591   1                         ratio_vertical * weight_vertical) * 100.0f);
  592   1          
  593   1          // åº”ç”¨ä¸­å¿ƒç”µæ„Ÿä¿®æ­£ - å‘ä¸­å¿ƒçº¿æ‹‰è¿‘
  594   1          pos = (int16)(pos * (1.0f - center_correction));
  595   1          
  596   1          // é™åˆ¶èŒƒå›´åœ¨-100åˆ°100ä¹‹é—´
  597   1          if(pos > 100) pos = 100;
  598   1          if(pos < -100) pos = -100;
  599   1          
  600   1          // ä½ç½®å˜åŒ–é‡é™åˆ¶ï¼Œé˜²æ­¢çªå˜
  601   1          position_change = pos - last_pos;
  602   1          if(position_change > max_change_rate)
  603   1              pos = last_pos + max_change_rate;
  604   1          else if(position_change < -max_change_rate)
  605   1              pos = last_pos - max_change_rate;
  606   1          
  607   1          // åº”ç”¨ä½é€šæ»¤æ³¢ï¼Œå¹³æ»‘ä½ç½®å˜åŒ–
  608   1          pos = (int16)(filter_param * pos + (1-filter_param) * last_pos);
  609   1          
  610   1          // å¦‚æœä¿¡å·å¼ºåº¦é«˜ï¼Œå¢å¼ºæ»¤æ³¢æ•ˆæœ
  611   1      //    if(signal_strength > 60.0f) {
  612   1      //        // åº”ç”¨ä¸‰ç‚¹å¹³å‡æ»¤æ³¢ï¼Œè¿›ä¸€æ­¥å¹³æ»‘
  613   1      //        pos = (pos + last_pos + very_last_pos) / 3;
  614   1      //    }
  615   1                      
  616   1                      
  617   1      //              if (track_type == 0 && (pos <= 10 || pos >= -10))
  618   1      //              {
  619   1      //                              speed_count++;
  620   1      //                      
  621   1      //                              if (speed_count >= 12)
  622   1      //                              {
  623   1      //                                              track_type = 4;
  624   1      //                                              speed_count = 0;
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           19/07/25  22:33:45  PAGE 11  

  625   1      //                              }
  626   1      //              }
  627   1      //              else
  628   1      //              {
  629   1      //                              speed_count = 0;
  630   1      //              }
  631   1      //              
  632   1      //              if (track_type == 4 && (pos > 10 || pos < -10))
  633   1      //              {
  634   1      //                      track_type = 0;
  635   1      //              }
  636   1                      
  637   1          
  638   1          // æ›´æ–°å†å²ä½ç½®å€¼
  639   1      //    very_very_last_pos = very_last_pos;
  640   1          very_last_pos = last_pos;
  641   1          last_pos = pos;
  642   1          
  643   1          return pos;
  644   1      }
  645          
  646          
  647          //-----------------------------------------------------------------------------
  648          // @brief       ç”µç£ä¿æŠ¤é€»è¾‘å‡½æ•°
  649          // @param   æ— 
  650          // @return  ä¿æŠ¤è§¦å‘æ ‡å¿—ä½ï¼Œ1è¡¨ç¤ºå·²è§¦å‘ä¿æŠ¤
  651          // @author  ZP
  652          // Sample usage: protection_flag = check_electromagnetic_protection();
  653          //-----------------------------------------------------------------------------
  654          uint8 check_electromagnetic_protection(void)
  655          {
  656   1          // åœ¨å‡½æ•°å¼€å§‹å¤„å£°æ˜æ‰€æœ‰å˜é‡
  657   1          uint8 is_out_of_track = 0;    // æ ‡è®°æ˜¯å¦è„±ç¦»èµ›é“çš„æ ‡å¿—ä½
  658   1          uint16 sum_value = 0;         // æ‰€æœ‰ç”µæ„Ÿå€¼çš„æ€»å’Œ
  659   1          uint16 threshold = 175;       // é˜ˆå€¼ï¼Œéœ€è¦æ ¹æ®ä¸ƒç”µæ„Ÿçš„å®é™…æƒ…å†µè°ƒæ•´ï¼ˆå¢åŠ ï¼‰
  660   1          static uint8 out_of_track_count = 0;    // è¿ç»­æ£€æµ‹åˆ°è„±ç¦»èµ›é“çš„æ¬¡æ•°è®¡æ•°å™¨
  661   1          static uint8 in_track_count = 0;        // è¿ç»­æ£€æµ‹åˆ°åœ¨è½¨é“ä¸Šçš„æ¬¡æ•°è®¡æ•°å™¨
  662   1          static uint8 protection_triggered = 0;  // ä¿æŠ¤è§¦å‘æ ‡å¿—ä½ï¼Œ1è¡¨ç¤ºå·²è§¦å‘ä¿æŠ¤
  663   1          uint8 i;
  664   1          uint8 trigger_reason = 0;     // è®°å½•è§¦å‘åŸå› ï¼Œç”¨äºè°ƒè¯•
  665   1          
  666   1          
  667   1              // è®¡ç®—æ‰€æœ‰ç”µæ„Ÿçš„å’Œå€¼
  668   1              for(i = 0; i < SENSOR_COUNT; i++)
  669   1              {
  670   2                      sum_value += result[i];
  671   2              }
  672   1              
  673   1              // åˆ¤æ–­æ˜¯å¦è„±ç¦»èµ›é“çš„æ¡ä»¶
  674   1              // 1. æ‰€æœ‰ç”µæ„Ÿå€¼æ€»å’Œè¿‡å°ï¼Œè¯´æ˜å¯èƒ½è„±ç¦»èµ›é“
  675   1              if(sum_value < threshold)
  676   1              {
  677   2                      is_out_of_track = 1;
  678   2                      trigger_reason = 1;
  679   2              }
  680   1              
  681   1              // 2. å½’ä¸€åŒ–åçš„å€¼éƒ½å¾ˆå°ï¼Œè¯´æ˜å¯èƒ½è„±ç¦»èµ›é“
  682   1              if(normalized_data[SENSOR_HL] < 5.0f && normalized_data[SENSOR_VL] < 5.0f && 
  683   1                 normalized_data[SENSOR_HML] < 5.0f && normalized_data[SENSOR_HC] < 5.0f && 
  684   1                 normalized_data[SENSOR_HMR] < 5.0f && normalized_data[SENSOR_VR] < 5.0f && 
  685   1                 normalized_data[SENSOR_HR] < 5.0f)
  686   1              {
  687   2                      is_out_of_track = 1;
  688   2                      trigger_reason = 2;
  689   2              }
  690   1              
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           19/07/25  22:33:45  PAGE 12  

  691   1              // 3. ä½ç½®åå·®è¿‡å¤§ï¼Œè¯´æ˜å¯èƒ½åç¦»èµ›é“å¤ªå¤š
  692   1              if(position < -90 || position > 90)
  693   1              {
  694   2                      // åªæœ‰å½“ç”µæ„Ÿå€¼æ€»å’Œä¹Ÿè¾ƒå°æ—¶æ‰åˆ¤æ–­ä¸ºå‡ºèµ›é“
  695   2                      if(sum_value < threshold * 2)
  696   2                      {
  697   3                              is_out_of_track = 1;
  698   3                              trigger_reason = 3;
  699   3                      }
  700   2              }
  701   1              
  702   1              // è¿ç»­æ£€æµ‹é€»è¾‘ï¼Œé˜²æ­¢å¶ç„¶çš„ä½å€¼å¯¼è‡´è¯¯åˆ¤
  703   1              if(is_out_of_track)
  704   1              {
  705   2                      out_of_track_count++;
  706   2                      in_track_count = 0;  // é‡ç½®åœ¨è½¨é“ä¸Šçš„è®¡æ•°
  707   2                      
  708   2                      if(out_of_track_count >= 50 && !protection_triggered)  // è¿ç»­5æ¬¡æ£€æµ‹åˆ°è„±ç¦»èµ›é“æ‰è§¦å‘ä¿æŠ
             -¤
  709   2                      {
  710   3                              protection_triggered = 1;
  711   3                              // è¿™é‡Œå¯ä»¥è¾“å‡ºè§¦å‘ä¿æŠ¤çš„ä¿¡æ¯ï¼Œç”¨äºè°ƒè¯•
  712   3      ////            sprintf(g_TxData, "Protection triggered! Reason: %d, Sum: %d\n", trigger_reason, sum_valu
             -e);
  713   3      ////            uart_putstr(UART_4, g_TxData);
  714   3                      }
  715   2              }
  716   1              // else
  717   1              // {
  718   1              //     // å¦‚æœæ£€æµ‹æ­£å¸¸ï¼Œè®¡æ•°å™¨å¢åŠ 
  719   1              //     in_track_count++;
  720   1              //     if(out_of_track_count > 0)
  721   1              //         out_of_track_count--;
  722   1                              
  723   1              //     // è‡ªåŠ¨æ¢å¤æœºåˆ¶ï¼šè¿ç»­20æ¬¡æ£€æµ‹åˆ°æ­£å¸¸ï¼Œåˆ™è§£é™¤ä¿æŠ¤çŠ¶æ€
  724   1              //     if(in_track_count >= 20 && protection_triggered)
  725   1              //     {
  726   1              //         protection_triggered = 0;
  727   1              //         out_of_track_count = 0;
  728   1              //         in_track_count = 0;
  729   1              //         // å¯ä»¥è¾“å‡ºè‡ªåŠ¨æ¢å¤çš„ä¿¡æ¯ï¼Œç”¨äºè°ƒè¯•
  730   1              //         // sprintf(g_TxData, "Protection auto reset!\n");
  731   1              //         // uart_putstr(UART_4, g_TxData);
  732   1              //     }
  733   1              // }
  734   1                      
  735   1              return protection_triggered;
  736   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      5755     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       782     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
C251 COMPILER V5.60.0,  electromagnetic_tracking                                           19/07/25  22:33:45  PAGE 13  

  hconst size          =       739     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
