C251 COMPILER V5.60.0,  SEEKFREE_IMU963RA                                                  14/07/25  14:27:43  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE SEEKFREE_IMU963RA
OBJECT MODULE PLACED IN .\Out_File\SEEKFREE_IMU963RA.obj
COMPILER INVOKED BY: D:\Software\Keil5\c251v560\C251\BIN\C251.EXE ..\seekfree_peripheral\SEEKFREE_IMU963RA.c LARGE INTR2
                    - WARNINGLEVEL(3) OPTIMIZE(0,SPEED) BROWSE INCDIR(..\USER\inc;..\USER\src;..\libraries;..\seekfree_libraries;..\seekfree_
                    -peripheral) DEBUG PRINT(.\Out_File\SEEKFREE_IMU963RA.lst) OBJECT(.\Out_File\SEEKFREE_IMU963RA.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2           * COPYRIGHT NOTICE
    3           * Copyright (c) 2018,é€é£ç§‘æŠ€
    4           * All rights reserved.
    5           * æŠ€æœ¯è®¨è®ºQQç¾¤ï¼šä¸€ç¾¤ï¼š179029047(å·²æ»¡)  äºŒç¾¤ï¼š244861897
    6           *
    7           * ä»¥ä¸‹æ‰€æœ‰å†…å®¹ç‰ˆæƒå‡å±é€é£ç§‘æŠ€æ‰€æœ‰ï¼Œæœªç»å…è®¸ä¸å¾—ç”¨äºå•†ä¸šç”¨é€”ï¼Œ
    8           * æ¬¢è¿å„ä½ä½¿ç”¨å¹¶ä¼ æ’­æœ¬ç¨‹åºï¼Œä¿®æ”¹å†…å®¹æ—¶å¿…é¡»ä¿ç•™é€é£ç§‘æŠ€çš„ç‰ˆæƒå£°æ˜ã€‚
    9           *
   10           * @file                IMU963RA
   11           * @company                     æˆéƒ½é€é£ç§‘æŠ€æœ‰é™å…¬å¸
   12           * @author              é€é£ç§‘æŠ€(QQ3184284598)
   13           * @version             æŸ¥çœ‹docå†…versionæ–‡ä»¶ ç‰ˆæœ¬è¯´æ˜
   14           * @Software            MDK FOR C251 V5.60
   15           * @Target core         STC32G12K128
   16           * @Taobao              https://seekfree.taobao.com/
   17           * @date                2019-04-30
   18           * @note
   19           * æ¥çº¿å®šä¹‰ï¼š
   20           *                   ------------------------------------
   21           *                   æ¨¡å—ç®¡è„š            å•ç‰‡æœºç®¡è„š
   22           *                   // ç¡¬ä»¶ SPI å¼•è„š
   23           *                   SCL/SPC             æŸ¥çœ‹ SEEKFREE_IMU963RA.h ä¸­ IMU963RA_SPC_PIN å®å®šä¹‰
   24           *                   SDA/DSI             æŸ¥çœ‹ SEEKFREE_IMU963RA.h ä¸­ IMU963RA_SDI_PIN å®å®šä¹‰
   25           *                   SA0/SDO             æŸ¥çœ‹ SEEKFREE_IMU963RA.h ä¸­ IMU963RA_SDO_PIN å®å®šä¹‰
   26           *                   CS                  æŸ¥çœ‹ SEEKFREE_IMU963RA.h ä¸­ IMU963RA_CS_PIN  å®å®šä¹‰
   27           *                   VCC                 3.3Vç”µæº
   28           *                   GND                 ç”µæºåœ°
   29           *                   å…¶ä½™å¼•è„šæ‚¬ç©º
   30           *
   31           *                   // è½¯ä»¶ IIC å¼•è„š
   32           *                   SCL/SPC             æŸ¥çœ‹ SEEKFREE_IMU963RA.h ä¸­ IMU963RA_SCL_PIN å®å®šä¹‰
   33           *                   SDA/DSI             æŸ¥çœ‹ SEEKFREE_IMU963RA.h ä¸­ IMU963RA_SDA_PIN å®å®šä¹‰
   34           *                   VCC                 3.3Vç”µæº
   35           *                   GND                 ç”µæºåœ°
   36           *                   å…¶ä½™å¼•è„šæ‚¬ç©º
   37           *                   ------------------------------------
   38          *********************************************************************************************************
             -***********/
   39          
   40          #include "SEEKFREE_IMU963RA.h"
   41          
   42          
   43          #include "zf_delay.h"
   44          #include "zf_spi.h"
   45          #include "fixed_point.h"  // æ·»åŠ å®šç‚¹æ•°æ”¯æŒ (ä»»åŠ¡4.8)
   46          
   47          
   48          #pragma warning disable = 177
   49          #pragma warning disable = 183
   50          
   51          volatile int32_t gyro_z_offset_fixed = 0;
   52          
   53          
   54          int16 imu963ra_gyro_x = 0, imu963ra_gyro_y = 0, imu963ra_gyro_z = 0;
   55          int16 imu963ra_acc_x = 0,  imu963ra_acc_y = 0,  imu963ra_acc_z = 0;
C251 COMPILER V5.60.0,  SEEKFREE_IMU963RA                                                  14/07/25  14:27:43  PAGE 2   

   56          int16 imu963ra_mag_x = 0,  imu963ra_mag_y = 0,  imu963ra_mag_z = 0;
   57          
   58          
   59          //-------------------------------------------------------------------------------------------------------
             -------------
   60          //  @brief      é€šè¿‡SPIå†™ä¸€ä¸ªbyte,åŒæ—¶è¯»å–ä¸€ä¸ªbyte
   61          //  @param      byte        å‘é€çš„æ•°æ®
   62          //  @return     uint8 xdata       return è¿”å›statusçŠ¶æ€
   63          //  @since      v1.0
   64          //  Sample usage:
   65          //-------------------------------------------------------------------------------------------------------
             -------------
   66          static uint8 imu963ra_simspi_wr_byte(uint8 byte)
   67          {
   68   1              uint8 buffer;
   69   1              
   70   1          buffer = spi_mosi(byte);
   71   1              
   72   1          return(buffer);
   73   1      }
   74          //-------------------------------------------------------------------------------------------------------
             -------------
   75          //  @brief      å°†valå†™å…¥cmdå¯¹åº”çš„å¯„å­˜å™¨åœ°å€,åŒæ—¶è¿”å›statuså­—èŠ‚
   76          //  @param      cmd         å‘½ä»¤å­—
   77          //  @param      val         å¾…å†™å…¥å¯„å­˜å™¨çš„æ•°å€¼
   78          //  @since      v1.0
   79          //  Sample usage:
   80          //-------------------------------------------------------------------------------------------------------
             -------------
   81          static void imu963ra_simspi_w_reg_byte(uint8 cmd, uint8 val)
   82          {
   83   1          IMU963RA_CS(0);
   84   1          cmd |= IMU963RA_SPI_W;
   85   1          imu963ra_simspi_wr_byte(cmd);
   86   1          imu963ra_simspi_wr_byte(val);
   87   1          IMU963RA_CS(1);
   88   1      }
   89          
   90          
   91          //-------------------------------------------------------------------------------------------------------
             -------------
   92          //  @brief      å°†valå†™å…¥cmdå¯¹åº”çš„å¯„å­˜å™¨åœ°å€
   93          //  @param      cmd         å‘½ä»¤å­—
   94          //  @param      val         å¾…å†™å…¥å¯„å­˜å™¨çš„æ•°å€¼
   95          //  @since      v1.0
   96          //  Sample usage:
   97          //-------------------------------------------------------------------------------------------------------
             -------------
   98          //static void imu963ra_simspi_w_reg_bytes(uint8 cmd, uint8 *dat_addr, uint32 len)
   99          //{
  100          
  101          //
  102          //    IMU963RA_CS(0);
  103          //    cmd |= IMU963RA_SPI_W;
  104          //    imu963ra_simspi_wr_byte(cmd);
  105          //      while(len--)
  106          //      {
  107          //              imu963ra_simspi_wr_byte(*dat_addr++);
  108          //      }
  109          //    IMU963RA_CS(1);
  110          //}
  111          
  112          //-------------------------------------------------------------------------------------------------------
             -------------
  113          //  @brief      è¯»å–cmdæ‰€å¯¹åº”çš„å¯„å­˜å™¨åœ°å€
  114          //  @param      cmd         å‘½ä»¤å­—
C251 COMPILER V5.60.0,  SEEKFREE_IMU963RA                                                  14/07/25  14:27:43  PAGE 3   

  115          //  @param      *val        å­˜å‚¨è¯»å–çš„æ•°æ®åœ°å€
  116          //  @since      v1.0
  117          //  Sample usage:
  118          //-------------------------------------------------------------------------------------------------------
             -------------
  119          static void imu963ra_simspi_r_reg_byte(uint8 cmd, uint8 *val)
  120          {
  121   1          IMU963RA_CS(0);
  122   1          cmd |= IMU963RA_SPI_R;
  123   1          imu963ra_simspi_wr_byte(cmd);
  124   1          *val = imu963ra_simspi_wr_byte(0);
  125   1          IMU963RA_CS(1);
  126   1      }
  127          
  128          //-------------------------------------------------------------------------------------------------------
             -------------
  129          //  @brief      è¯»å–cmdæ‰€å¯¹åº”çš„å¯„å­˜å™¨åœ°å€
  130          //  @param      cmd         å‘½ä»¤å­—
  131          //  @param      *val        å­˜å‚¨è¯»å–çš„æ•°æ®åœ°å€
  132          //  @param      num         è¯»å–çš„æ•°é‡
  133          //  @since      v1.0
  134          //  Sample usage:
  135          //-------------------------------------------------------------------------------------------------------
             -------------
  136          static void imu963ra_simspi_r_reg_bytes(uint8 cmd, uint8 *val, uint32 num)
  137          {
  138   1          cmd |= IMU963RA_SPI_R;
  139   1          imu963ra_simspi_wr_byte(cmd);
  140   1          while(num--)
  141   1          {
  142   2              *val++ = imu963ra_simspi_wr_byte(0);
  143   2          }
  144   1      }
  145          
  146          
  147          
  148          //-------------------------------------------------------------------------------------------------------
             -------------
  149          // å‡½æ•°ç®€ä»‹     IMU963RA å†™å¯„å­˜å™¨
  150          // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  151          // å‚æ•°è¯´æ˜     dat            æ•°æ®
  152          // è¿”å›å‚æ•°     void
  153          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_write_acc_gyro_register(IMU963RA_SLV0_CONFIG, 0x00);
  154          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  155          //-------------------------------------------------------------------------------------------------------
             -------------
  156          static void imu963ra_write_acc_gyro_register(uint8 reg, uint8 dat)
  157          {
  158   1          IMU963RA_CS(0);
  159   1          imu963ra_simspi_w_reg_byte(reg | IMU963RA_SPI_W, dat);
  160   1          IMU963RA_CS(1);
  161   1      }
  162          
  163          //-------------------------------------------------------------------------------------------------------
             -------------
  164          // å‡½æ•°ç®€ä»‹     IMU963RA è¯»å¯„å­˜å™¨
  165          // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  166          // è¿”å›å‚æ•°     uint8 xdata           æ•°æ®
  167          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_read_acc_gyro_register(IMU963RA_STATUS_MASTER);
  168          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  169          //-------------------------------------------------------------------------------------------------------
             -------------
  170          static uint8 imu963ra_read_acc_gyro_register(uint8 reg)
  171          {
  172   1          uint8 xdata dat = 0;
  173   1          IMU963RA_CS(0);
C251 COMPILER V5.60.0,  SEEKFREE_IMU963RA                                                  14/07/25  14:27:43  PAGE 4   

  174   1          imu963ra_simspi_r_reg_byte(reg | IMU963RA_SPI_R, &dat);
  175   1          IMU963RA_CS(1);
  176   1          return dat;
  177   1      }
  178          
  179          //-------------------------------------------------------------------------------------------------------
             -------------
  180          // å‡½æ•°ç®€ä»‹     IMU963RA è¯»æ•°æ® å†…éƒ¨è°ƒç”¨
  181          // å‚æ•°è¯´æ˜     reg             å¯„å­˜å™¨åœ°å€
  182          // å‚æ•°è¯´æ˜     dat            æ•°æ®ç¼“å†²åŒº
  183          // å‚æ•°è¯´æ˜     len             æ•°æ®é•¿åº¦
  184          // è¿”å›å‚æ•°     void
  185          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_read_acc_gyro_registers(IMU963RA_OUTX_L_A, dat, 6);
  186          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  187          //-------------------------------------------------------------------------------------------------------
             -------------
  188          static void imu963ra_read_acc_gyro_registers(uint8 reg, uint8 *dat, uint32 len)
  189          {
  190   1          IMU963RA_CS(0);
  191   1          imu963ra_simspi_r_reg_bytes( reg | IMU963RA_SPI_R, dat, len);
  192   1          IMU963RA_CS(1);
  193   1      }
  194          
  195          
  196          //-------------------------------------------------------------------------------------------------------
             -------------
  197          // å‡½æ•°ç®€ä»‹     IMU963RA ä½œä¸º IIC ä¸»æœºå‘ç£åŠ›è®¡å†™æ•°æ®
  198          // å‚æ•°è¯´æ˜     addr            ç›®æ ‡åœ°å€
  199          // å‚æ•°è¯´æ˜     reg             ç›®æ ‡å¯„å­˜å™¨
  200          // å‚æ•°è¯´æ˜     dat            æ•°æ®
  201          // è¿”å›å‚æ•°     uint8 xdata           1-å¤±è´¥ 0-æˆåŠŸ
  202          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CONTROL2, 0x80);
  203          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  204          //-------------------------------------------------------------------------------------------------------
             -------------
  205          static uint8 imu963ra_write_mag_register (uint8 addr, uint8 reg, uint8 dat)
  206          {
  207   1          uint8 xdata return_state = 0;
  208   1          uint16 xdata timeout_count = 0;
  209   1          addr = addr << 1;
  210   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_CONFIG, 0x00);               // ä»æœº0é…ç½®æ¸…é™¤
  211   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_ADD, addr | 0);              // è®¾ç½®åœ°ç£è®¡åœ°å€ï
             -¼ˆæ³¨æ„è¿™é‡Œéœ€è¦è®¾ç½®8ä½çš„I2Cåœ°å€ï¼‰ 0x2C
  212   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_SUBADD, reg);                // éœ€è¦å†™å…¥çš„å¯„å­˜å
             -™¨åœ°å€
  213   1          imu963ra_write_acc_gyro_register(IMU963RA_DATAWRITE_SLV0, dat);            // éœ€è¦å†™å…¥çš„æ•°æ®
  214   1          imu963ra_write_acc_gyro_register(IMU963RA_MASTER_CONFIG, 0x4C);             // ä»…åœ¨ç¬¬ä¸€ä¸ªå‘¨æœŸå
             -¯ç”¨é€šè®¯ å¼€å¯ä¸Šæ‹‰ I2Cä¸»æœºä½¿èƒ½
  215   1          // ç­‰å¾…é€šè®¯æˆåŠŸ
  216   1          while(0 == (0x80 & imu963ra_read_acc_gyro_register(IMU963RA_STATUS_MASTER)))
  217   1          {
  218   2              if(timeout_count ++ > IMU963RA_TIMEOUT_COUNT)
  219   2              {
  220   3                  return_state = 1;
  221   3                  break;
  222   3              }
  223   2              delay_ms(2);
  224   2          }
  225   1          return return_state;
  226   1      }
  227          
  228          //-------------------------------------------------------------------------------------------------------
             -------------
  229          // å‡½æ•°ç®€ä»‹     IMU963RA ä½œä¸º IIC ä¸»æœºå‘ç£åŠ›è®¡è¯»æ•°æ®
  230          // å‚æ•°è¯´æ˜     addr            ç›®æ ‡åœ°å€
  231          // å‚æ•°è¯´æ˜     reg             ç›®æ ‡å¯„å­˜å™¨
C251 COMPILER V5.60.0,  SEEKFREE_IMU963RA                                                  14/07/25  14:27:43  PAGE 5   

  232          // è¿”å›å‚æ•°     uint8 xdata           è¯»å–çš„æ•°æ®
  233          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_read_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CHIP_ID);
  234          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  235          //-------------------------------------------------------------------------------------------------------
             -------------
  236          static uint8 imu963ra_read_mag_register (uint8 addr, uint8 reg)
  237          {
  238   1          uint16 xdata timeout_count = 0;
  239   1          addr = addr << 1;
  240   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_ADD, addr | 1);              // è®¾ç½®åœ°ç£è®¡åœ°å€ï
             -¼ˆæ³¨æ„è¿™é‡Œéœ€è¦è®¾ç½®8ä½çš„I2Cåœ°å€ï¼‰ 0x2C
  241   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_SUBADD, reg);                // éœ€è¦è¯»å–çš„å¯„å­˜å
             -™¨åœ°å€
  242   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_CONFIG, 0x01);
  243   1          imu963ra_write_acc_gyro_register(IMU963RA_MASTER_CONFIG, 0x4C);             // ä»…åœ¨ç¬¬ä¸€ä¸ªå‘¨æœŸå
             -¯ç”¨é€šè®¯ å¼€å¯ä¸Šæ‹‰ I2Cä¸»æœºä½¿èƒ½
  244   1          // ç­‰å¾…é€šè®¯æˆåŠŸ
  245   1          while(0 == (0x01 & imu963ra_read_acc_gyro_register(IMU963RA_STATUS_MASTER)))
  246   1          {
  247   2              if(timeout_count ++ > IMU963RA_TIMEOUT_COUNT)
  248   2              {
  249   3                  break;
  250   3              }
  251   2              delay_ms(2);
  252   2          }
  253   1          return (imu963ra_read_acc_gyro_register(IMU963RA_SENSOR_HUB_1));            // è¿”å›è¯»å–åˆ°çš„æ•°æ
             -®
  254   1      }
  255          
  256          //-------------------------------------------------------------------------------------------------------
             -------------
  257          // å‡½æ•°ç®€ä»‹     IMU963RA ä½œä¸º IIC ä¸»æœºå‘ç£åŠ›è®¡è‡ªåŠ¨å†™æ•°æ®
  258          // å‚æ•°è¯´æ˜     addr            ç›®æ ‡åœ°å€
  259          // å‚æ•°è¯´æ˜     reg             ç›®æ ‡å¯„å­˜å™¨
  260          // è¿”å›å‚æ•°     void
  261          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_connect_mag(IMU963RA_MAG_ADDR, IMU963RA_MAG_OUTX_L);
  262          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  263          //-------------------------------------------------------------------------------------------------------
             -------------
  264          static void imu963ra_connect_mag (uint8 addr, uint8 reg)
  265          {
  266   1          addr = addr << 1;
  267   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_ADD, addr | 1);              // è®¾ç½®åœ°ç£è®¡åœ°å€ï
             -¼ˆæ³¨æ„è¿™é‡Œéœ€è¦è®¾ç½®8ä½çš„I2Cåœ°å€ï¼‰ 0x2C
  268   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_SUBADD, reg);                // éœ€è¦è¯»å–çš„å¯„å­˜å
             -™¨åœ°å€
  269   1          imu963ra_write_acc_gyro_register(IMU963RA_SLV0_CONFIG, 0x06);
  270   1          imu963ra_write_acc_gyro_register(IMU963RA_MASTER_CONFIG, 0x6C);             // ä»…åœ¨ç¬¬ä¸€ä¸ªå‘¨æœŸå
             -¯ç”¨é€šè®¯ å¼€å¯ä¸Šæ‹‰ I2Cä¸»æœºä½¿èƒ½
  271   1      }
  272          
  273          
  274          //-------------------------------------------------------------------------------------------------------
             -------------
  275          // å‡½æ•°ç®€ä»‹     IMU963RA å…­è½´è‡ªæ£€ å†…éƒ¨è°ƒç”¨
  276          // å‚æ•°è¯´æ˜     void
  277          // è¿”å›å‚æ•°     uint8 xdata           1-è‡ªæ£€å¤±è´¥ 0-è‡ªæ£€æˆåŠŸ
  278          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_acc_gyro_self_check();
  279          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  280          //-------------------------------------------------------------------------------------------------------
             -------------
  281          static uint8 imu963ra_acc_gyro_self_check (void)
  282          {
  283   1          uint8 xdata return_state = 0;
  284   1          uint8 xdata dat = 0;
  285   1          uint16 xdata timeout_count = 0;
C251 COMPILER V5.60.0,  SEEKFREE_IMU963RA                                                  14/07/25  14:27:43  PAGE 6   

  286   1          while(0x6B != dat)                                                          // åˆ¤æ–­ ID æ˜¯å¦æ­£ç¡®
  287   1          {
  288   2              if(timeout_count++ > IMU963RA_TIMEOUT_COUNT)
  289   2              {
  290   3                  return_state = 1;
  291   3                  break;
  292   3              }
  293   2              dat = imu963ra_read_acc_gyro_register(IMU963RA_WHO_AM_I);
  294   2              delay_ms(10);
  295   2          }
  296   1          return return_state;
  297   1      }
  298          
  299          //-------------------------------------------------------------------------------------------------------
             -------------
  300          // å‡½æ•°ç®€ä»‹     IMU963RA ç£åŠ›è®¡è‡ªæ£€ å†…éƒ¨è°ƒç”¨
  301          // å‚æ•°è¯´æ˜     void
  302          // è¿”å›å‚æ•°     uint8 xdata           1-è‡ªæ£€å¤±è´¥ 0-è‡ªæ£€æˆåŠŸ
  303          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_mag_self_check();
  304          // å¤‡æ³¨ä¿¡æ¯     å†…éƒ¨è°ƒç”¨
  305          //-------------------------------------------------------------------------------------------------------
             -------------
  306          static uint8 imu963ra_mag_self_check (void)
  307          {
  308   1          uint8 xdata return_state = 0;
  309   1          uint8 xdata dat = 0;
  310   1          uint16 xdata timeout_count = 0;
  311   1          while(0xff != dat)                                                          // åˆ¤æ–­ ID æ˜¯å¦æ­£ç¡®
  312   1          {
  313   2              if(timeout_count++ > IMU963RA_TIMEOUT_COUNT)
  314   2              {
  315   3                  return_state = 1;
  316   3                  break;
  317   3              }
  318   2              dat = imu963ra_read_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CHIP_ID);
  319   2              delay_ms(10);
  320   2          }
  321   1          return return_state;
  322   1      }
  323          
  324          //-------------------------------------------------------------------------------------------------------
             -------------
  325          // å‡½æ•°ç®€ä»‹     è·å– IMU963RA åŠ é€Ÿåº¦è®¡æ•°æ®
  326          // å‚æ•°è¯´æ˜     void
  327          // è¿”å›å‚æ•°     void
  328          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_get_acc();
  329          // å¤‡æ³¨ä¿¡æ¯     æ‰§è¡Œè¯¥å‡½æ•°åï¼Œç›´æ¥æŸ¥çœ‹å¯¹åº”çš„å˜é‡å³å¯
  330          //-------------------------------------------------------------------------------------------------------
             -------------
  331          void imu963ra_get_acc (void)
  332          {
  333   1          uint8 xdata dat[6];
  334   1          imu963ra_read_acc_gyro_registers(IMU963RA_OUTX_L_A, dat, 6);
  335   1          imu963ra_acc_x = (int16)(((uint16)dat[1]<<8 | dat[0]));
  336   1          imu963ra_acc_y = (int16)(((uint16)dat[3]<<8 | dat[2]));
  337   1          imu963ra_acc_z = (int16)(((uint16)dat[5]<<8 | dat[4]));
  338   1      }
  339          
  340          
  341          //-------------------------------------------------------------------------------------------------------
             -------------
  342          // å‡½æ•°ç®€ä»‹     è·å–IMU963RAé™€èºä»ªæ•°æ®
  343          // å‚æ•°è¯´æ˜     void
  344          // è¿”å›å‚æ•°     void
  345          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_get_gyro();
  346          // å¤‡æ³¨ä¿¡æ¯     æ‰§è¡Œè¯¥å‡½æ•°åï¼Œç›´æ¥æŸ¥çœ‹å¯¹åº”çš„å˜é‡å³å¯
C251 COMPILER V5.60.0,  SEEKFREE_IMU963RA                                                  14/07/25  14:27:43  PAGE 7   

  347          //-------------------------------------------------------------------------------------------------------
             -------------
  348          void imu963ra_get_gyro (void)
  349          {
  350   1          uint8 xdata dat[6];
  351   1          imu963ra_read_acc_gyro_registers(IMU963RA_OUTX_L_G, dat, 6);
  352   1          imu963ra_gyro_x = (int16)(((uint16)dat[1]<<8 | dat[0]));
  353   1          imu963ra_gyro_y = (int16)(((uint16)dat[3]<<8 | dat[2]));
  354   1          imu963ra_gyro_z = (int16)(((uint16)dat[5]<<8 | dat[4]));
  355   1      }
  356          
  357          
  358          //-------------------------------------------------------------------------------------------------------
             -------------
  359          // å‡½æ•°ç®€ä»‹     è·å– IMU963RA ç£åŠ›è®¡æ•°æ®
  360          // å‚æ•°è¯´æ˜     void
  361          // è¿”å›å‚æ•°     void
  362          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_get_mag();
  363          // å¤‡æ³¨ä¿¡æ¯     æ‰§è¡Œè¯¥å‡½æ•°åï¼Œç›´æ¥æŸ¥çœ‹å¯¹åº”çš„å˜é‡å³å¯
  364          //-------------------------------------------------------------------------------------------------------
             -------------
  365          void imu963ra_get_mag (void)
  366          {
  367   1          uint8 xdata temp_status;
  368   1          uint8 xdata dat[6];
  369   1          imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x40);
  370   1          temp_status = imu963ra_read_acc_gyro_register(IMU963RA_STATUS_MASTER);
  371   1          if(0x01 & temp_status)
  372   1          {
  373   2              imu963ra_read_acc_gyro_registers(IMU963RA_SENSOR_HUB_1, dat, 6);
  374   2              imu963ra_mag_x = (int16)(((uint16)dat[1]<<8 | dat[0]));
  375   2              imu963ra_mag_y = (int16)(((uint16)dat[3]<<8 | dat[2]));
  376   2              imu963ra_mag_z = (int16)(((uint16)dat[5]<<8 | dat[4]));
  377   2          }
  378   1          imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x00);
  379   1      }
  380          
  381          //-------------------------------------------------------------------------------------------------------
             -------------
  382          // å‡½æ•°ç®€ä»‹     å°† IMU963RA åŠ é€Ÿåº¦è®¡æ•°æ®è½¬æ¢ä¸ºå®é™…ç‰©ç†æ•°æ®
  383          // å‚æ•°è¯´æ˜     gyro_value      ä»»æ„è½´çš„åŠ é€Ÿåº¦è®¡æ•°æ®
  384          // è¿”å›å‚æ•°     void
  385          // ä½¿ç”¨ç¤ºä¾‹     float dat = imu963ra_acc_transition(imu963ra_acc_x);           // å•ä½ä¸º g(m/s^2)
  386          // å¤‡æ³¨ä¿¡æ¯
  387          //-------------------------------------------------------------------------------------------------------
             -------------
  388          float imu963ra_acc_transition (int16 acc_value)
  389          {
  390   1          float acc_dat = 0;
  391   1          switch(IMU963RA_ACC_SAMPLE)
  392   1          {
  393   2              case 0x30:
  394   2                  acc_dat = (float)acc_value / 16393;
  395   2                  break;                  // 0x30 åŠ é€Ÿåº¦é‡ç¨‹ä¸º:Â±2G      è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é
             -™¤ä»¥ 16393 ï¼Œå¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ï¼šg(m/s^2)
  396   2              case 0x38:
  397   2                  acc_dat = (float)acc_value / 8197;
  398   2                  break;                  // 0x38 åŠ é€Ÿåº¦é‡ç¨‹ä¸º:Â±4G      è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é
             -™¤ä»¥ 8197 ï¼Œ å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ï¼šg(m/s^2)
  399   2              case 0x3C:
  400   2                  acc_dat = (float)acc_value / 4098;
  401   2                  break;                  // 0x3C åŠ é€Ÿåº¦é‡ç¨‹ä¸º:Â±8G      è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é
             -™¤ä»¥ 4098 ï¼Œ å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ï¼šg(m/s^2)
  402   2              case 0x34:
  403   2                  acc_dat = (float)acc_value / 2049;
  404   2                  break;                  // 0x34 åŠ é€Ÿåº¦é‡ç¨‹ä¸º:Â±16G     è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é
C251 COMPILER V5.60.0,  SEEKFREE_IMU963RA                                                  14/07/25  14:27:43  PAGE 8   

             -™¤ä»¥ 2049 ï¼Œ å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ï¼šg(m/s^2)
  405   2              default:
  406   2                  break;
  407   2          }
  408   1          return acc_dat;
  409   1      }
  410          
  411          //-------------------------------------------------------------------------------------------------------
             -------------
  412          // å‡½æ•°ç®€ä»‹     å°† IMU963RA é™€èºä»ªæ•°æ®è½¬æ¢ä¸ºå®é™…ç‰©ç†æ•°æ®
  413          // å‚æ•°è¯´æ˜     gyro_value      ä»»æ„è½´çš„é™€èºä»ªæ•°æ®
  414          // è¿”å›å‚æ•°     void
  415          // ä½¿ç”¨ç¤ºä¾‹     float dat = imu963ra_gyro_transition(imu963ra_gyro_x);         // å•ä½ä¸ºÂ°/s
  416          // å¤‡æ³¨ä¿¡æ¯
  417          //-------------------------------------------------------------------------------------------------------
             -------------
  418          float imu963ra_gyro_transition (int16 gyro_value)
  419          {
  420   1          float gyro_dat = 0;
  421   1          switch(IMU963RA_GYR_SAMPLE)
  422   1          {
  423   2              case 0x52:
  424   2                  gyro_dat = (float)gyro_value / 228.6f;
  425   2                  break;              //  0x52 é™€èºä»ªé‡ç¨‹ä¸º:Â±125dps  è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 2
             -28.6ï¼Œ   å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ä¸ºï¼šÂ°/s
  426   2              case 0x50:
  427   2                  gyro_dat = (float)gyro_value / 114.3f;
  428   2                  break;              //  0x50 é™€èºä»ªé‡ç¨‹ä¸º:Â±250dps  è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 1
             -14.3ï¼Œ   å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ä¸ºï¼šÂ°/s
  429   2              case 0x54:
  430   2                  gyro_dat = (float)gyro_value / 57.1f;
  431   2                  break;              //  0x54 é™€èºä»ªé‡ç¨‹ä¸º:Â±500dps  è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 5
             -7.1ï¼Œ    å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ä¸ºï¼šÂ°/s
  432   2              case 0x58:
  433   2                  gyro_dat = (float)gyro_value / 28.6f;
  434   2                  break;              //  0x58 é™€èºä»ªé‡ç¨‹ä¸º:Â±1000dps è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 2
             -8.6ï¼Œ    å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ä¸ºï¼šÂ°/s
  435   2              case 0x5C:
  436   2                  gyro_dat = (float)gyro_value / 14.3f;
  437   2                  break;              //  0x5C é™€èºä»ªé‡ç¨‹ä¸º:Â±2000dps è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 1
             -4.3ï¼Œ    å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ä¸ºï¼šÂ°/s
  438   2              case 0x51:
  439   2                  gyro_dat = (float)gyro_value / 7.1f;
  440   2                  break;              //  0x51 é™€èºä»ªé‡ç¨‹ä¸º:Â±4000dps è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥ 7
             -.1ï¼Œ     å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ä¸ºï¼šÂ°/s
  441   2              default:
  442   2                  break;
  443   2          }
  444   1          return gyro_dat;
  445   1      }
  446          
  447          //-------------------------------------------------------------------------------------------------------
             -------------
  448          // å‡½æ•°ç®€ä»‹     å°† IMU963RA åœ°ç£è®¡æ•°æ®è½¬æ¢ä¸ºå®é™…ç‰©ç†æ•°æ®
  449          // å‚æ•°è¯´æ˜     mag_value       ä»»æ„è½´çš„åœ°ç£è®¡æ•°æ®
  450          // è¿”å›å‚æ•°     void
  451          // ä½¿ç”¨ç¤ºä¾‹     float dat = imu963ra_mag_transition(imu963ra_mag_x);          // å•ä½ä¸ºG(é«˜æ–¯)
  452          // å¤‡æ³¨ä¿¡æ¯
  453          //-------------------------------------------------------------------------------------------------------
             -------------
  454          float imu963ra_mag_transition (int16 mag_value)
  455          {
  456   1          float mag_dat = 0;
  457   1          switch(IMU963RA_MAG_SAMPLE)
  458   1          {
  459   2              case 0x19:
C251 COMPILER V5.60.0,  SEEKFREE_IMU963RA                                                  14/07/25  14:27:43  PAGE 9   

  460   2                  mag_dat = (float)mag_value / 3000;
  461   2                  break;                  //  0x19 ç£åŠ›è®¡é‡ç¨‹ä¸º:8G     è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é™¤
             -ä»¥3000ï¼Œ å¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ï¼šG(é«˜æ–¯)
  462   2              case 0x09:
  463   2                  mag_dat = (float)mag_value / 12000;
  464   2                  break;                  //  0x09 ç£åŠ›è®¡é‡ç¨‹ä¸º:2G     è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é™¤
             -ä»¥12000ï¼Œå¯ä»¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ï¼šG(é«˜æ–¯)
  465   2              default:
  466   2                  break;
  467   2          }
  468   1          return mag_dat;
  469   1      }
  470          
  471          //-------------------------------------------------------------------------------------------------------
             -------------
  472          // å‡½æ•°ç®€ä»‹     åˆå§‹åŒ– IMU963RA
  473          // å‚æ•°è¯´æ˜     void
  474          // è¿”å›å‚æ•°     uint8 xdata           1-åˆå§‹åŒ–å¤±è´¥ 0-åˆå§‹åŒ–æˆåŠŸ
  475          // ä½¿ç”¨ç¤ºä¾‹     imu963ra_init();
  476          // å¤‡æ³¨ä¿¡æ¯
  477          //-------------------------------------------------------------------------------------------------------
             -------------
  478          uint8 imu963ra_init(void)
  479          {
  480   1          uint8 xdata return_state = 0;
  481   1              
  482   1              spi_init(IMU693RA_SPI, IMU963RA_CLK_PIN, IMU963RA_MOSI_PIN, IMU963RA_MISO_PIN, 0, MASTER, SPI_SYSclk_DIV
             -_4);
  483   1              
  484   1          delay_ms(10);                                                        // ä¸Šç”µå»¶æ—¶
  485   1      
  486   1          do
  487   1          {
  488   2              imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x00);       // å…³é—­HUBå¯„å­˜å™¨è®¿é
             -—®
  489   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL3_C, 0x01);               // å¤ä½è®¾å¤‡
  490   2                      
  491   2              delay_ms(2);
  492   2                      
  493   2              imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x00);       // å…³é—­HUBå¯„å­˜å™¨è®¿é
             -—®
  494   2                      
  495   2              if(imu963ra_acc_gyro_self_check())
  496   2              {
  497   3      //            printf( "IMU963RA acc and gyro self check error.\r\n");
  498   3                  return_state = 1;
  499   3                  break;
  500   3              }
  501   2                      
  502   2              imu963ra_write_acc_gyro_register(IMU963RA_INT1_CTRL, 0x03);             // å¼€å¯é™€èºä»ª åŠ é€Ÿ
             -åº¦æ•°æ®å°±ç»ªä¸­æ–­
  503   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL1_XL, IMU963RA_GYR_SAMPLE);   // è®¾ç½®åŠ é€Ÿåº¦è®¡
             -é‡ç¨‹ Â±8G ä»¥åŠæ•°æ®è¾“å‡ºé€Ÿç‡ 52hz ä»¥åŠåŠ é€Ÿåº¦ä¿¡æ¯ä»ç¬¬ä¸€çº§æ»¤æ³¢å™¨è¾“å‡º
  504   2              // IMU963RA_CTRL1_XL å¯„å­˜å™¨
  505   2              // è®¾ç½®ä¸º:0x30 åŠ é€Ÿåº¦é‡ç¨‹ä¸º:Â±2G      è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é™¤ä»¥16393ï¼Œå¯ä»
             -¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ï¼šg(m/s^2)
  506   2              // è®¾ç½®ä¸º:0x38 åŠ é€Ÿåº¦é‡ç¨‹ä¸º:Â±4G      è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é™¤ä»¥8197ï¼Œ å¯ä»
             -¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ï¼šg(m/s^2)
  507   2              // è®¾ç½®ä¸º:0x3C åŠ é€Ÿåº¦é‡ç¨‹ä¸º:Â±8G      è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é™¤ä»¥4098ï¼Œ å¯ä»
             -¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ï¼šg(m/s^2)
  508   2              // è®¾ç½®ä¸º:0x34 åŠ é€Ÿåº¦é‡ç¨‹ä¸º:Â±16G     è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é™¤ä»¥2049ï¼Œ å¯ä»
             -¥è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ï¼šg(m/s^2)
  509   2                      
  510   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL2_G, IMU963RA_ACC_SAMPLE);    // è®¾ç½®é™€èºä»ªè®¡
             -é‡ç¨‹ Â±2000dps ä»¥åŠæ•°æ®è¾“å‡ºé€Ÿç‡ 208hz
  511   2              // IMU963RA_CTRL2_G å¯„å­˜å™¨
C251 COMPILER V5.60.0,  SEEKFREE_IMU963RA                                                  14/07/25  14:27:43  PAGE 10  

  512   2              // è®¾ç½®ä¸º:0x52 é™€èºä»ªé‡ç¨‹ä¸º:Â±125dps  è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥228.6ï¼Œ   å¯ä»¥
             -è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ä¸ºï¼šÂ°/s
  513   2              // è®¾ç½®ä¸º:0x50 é™€èºä»ªé‡ç¨‹ä¸º:Â±250dps  è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥114.3ï¼Œ   å¯ä»¥
             -è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ä¸ºï¼šÂ°/s
  514   2              // è®¾ç½®ä¸º:0x54 é™€èºä»ªé‡ç¨‹ä¸º:Â±500dps  è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥57.1ï¼Œ    å¯ä»¥
             -è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ä¸ºï¼šÂ°/s
  515   2              // è®¾ç½®ä¸º:0x58 é™€èºä»ªé‡ç¨‹ä¸º:Â±1000dps è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥28.6ï¼Œ    å¯ä»¥
             -è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ä¸ºï¼šÂ°/s
  516   2              // è®¾ç½®ä¸º:0x5C é™€èºä»ªé‡ç¨‹ä¸º:Â±2000dps è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥14.3ï¼Œ    å¯ä»¥
             -è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ä¸ºï¼šÂ°/s
  517   2              // è®¾ç½®ä¸º:0x51 é™€èºä»ªé‡ç¨‹ä¸º:Â±4000dps è·å–åˆ°çš„é™€èºä»ªæ•°æ®é™¤ä»¥7.1ï¼Œ     å¯ä»¥
             -è½¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ä¸ºï¼šÂ°/s
  518   2                      
  519   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL3_C, 0x44);               // ä½¿èƒ½é™€èºä»ªæ•°å­—ä
             -½é€šæ»¤æ³¢å™¨
  520   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL4_C, 0x02);               // ä½¿èƒ½æ•°å­—ä½é€šæ»¤æ
             -³¢å™¨
  521   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL5_C, 0x00);               // åŠ é€Ÿåº¦è®¡ä¸é™€èºä
             -»ªå››èˆäº”å…¥
  522   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL6_C, 0x00);               // å¼€å¯åŠ é€Ÿåº¦è®¡é«˜æ
             -€§èƒ½æ¨¡å¼ é™€èºä»ªä½é€šæ»¤æ³¢ 133hz
  523   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL7_G, 0x00);               // å¼€å¯é™€èºä»ªé«˜æ€§è
             -ƒ½æ¨¡å¼ å…³é—­é«˜é€šæ»¤æ³¢
  524   2              imu963ra_write_acc_gyro_register(IMU963RA_CTRL9_XL, 0x01);              // å…³é—­I3Cæ¥å£
  525   2              imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x40);       // å¼€å¯HUBå¯„å­˜å™¨è®¿é
             -—® ç”¨äºé…ç½®åœ°ç£è®¡
  526   2              imu963ra_write_acc_gyro_register(IMU963RA_MASTER_CONFIG, 0x80);         // å¤ä½I2Cä¸»æœº
  527   2                      
  528   2              delay_ms(2);
  529   2              imu963ra_write_acc_gyro_register(IMU963RA_MASTER_CONFIG, 0x00);         // æ¸…é™¤å¤ä½æ ‡å¿—
  530   2                      
  531   2              delay_ms(2);
  532   2              imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CONTROL2, 0x80);// å¤ä½è¿æ¥çš„å¤–
             -è®¾
  533   2                      
  534   2              delay_ms(2);
  535   2              imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CONTROL2, 0x00);
  536   2                      
  537   2              delay_ms(2);
  538   2              if(imu963ra_mag_self_check())
  539   2              {
  540   3      //                      while(1)
  541   3      //                      {
  542   3      //              printf("IMU963RA mag self check error.\r\n");
  543   3      //                              delay_ms(200);
  544   3      //                      };
  545   3                  return_state = 1;
  546   3                  break;
  547   3              }
  548   2              imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_CONTROL1, IMU963RA_MAG_SAMPLE); // è®
             -¾ç½®ç£åŠ›è®¡é‡ç¨‹8G è¾“å‡ºé€Ÿç‡100hz è¿ç»­æ¨¡å¼
  549   2                      
  550   2              // IMU963RA_MAG_ADDR å¯„å­˜å™¨
  551   2              // è®¾ç½®ä¸º:0x19 ç£åŠ›è®¡é‡ç¨‹ä¸º:8G     è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é™¤ä»¥3000ï¼Œ å¯ä»¥è½
             -¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ï¼šG(é«˜æ–¯)
  552   2              // è®¾ç½®ä¸º:0x09 ç£åŠ›è®¡é‡ç¨‹ä¸º:2G     è·å–åˆ°çš„åŠ é€Ÿåº¦è®¡æ•°æ® é™¤ä»¥12000ï¼Œå¯ä»¥è½
             -¬åŒ–ä¸ºå¸¦ç‰©ç†å•ä½çš„æ•°æ®ï¼Œå•ä½ï¼šG(é«˜æ–¯)
  553   2              imu963ra_write_mag_register(IMU963RA_MAG_ADDR, IMU963RA_MAG_FBR, 0x01);
  554   2              imu963ra_connect_mag(IMU963RA_MAG_ADDR, IMU963RA_MAG_OUTX_L);
  555   2              imu963ra_write_acc_gyro_register(IMU963RA_FUNC_CFG_ACCESS, 0x00);       // å…³é—­HUBå¯„å­˜å™¨è®¿é
             -—®
  556   2                      
  557   2              delay_ms(20);                   // ç­‰å¾…ç£åŠ›è®¡è·å–æ•°æ®
  558   2                      
  559   2          }
  560   1          while(0);
C251 COMPILER V5.60.0,  SEEKFREE_IMU963RA                                                  14/07/25  14:27:43  PAGE 11  

  561   1          return return_state;
  562   1      }
  563          
  564          //-------------------------------------------------------------------------------------------------------
             -------------
  565          /**
  566           * @brief  å°† IMU963RA é™€èºä»ªåŸå§‹æ•°æ®è½¬æ¢ä¸ºå®šç‚¹æ•°å½¢å¼çš„è§’é€Ÿåº¦ (Â°/s * FX_SCALE)
  567           * @param  gyro_value  é™€èºä»ªåŸå§‹æ•°æ®ï¼ˆ16 ä½åŸå§‹æ•°ï¼‰
  568           * @return int32_t     æ”¾å¤§ FX_SCALE å€åçš„è§’é€Ÿåº¦
  569           */
  570          //-------------------------------------------------------------------------------------------------------
             -------------
  571          int32_t imu963ra_gyro_transition_fixed (int16 gyro_value)
  572          {
  573   1          // å˜é‡å£°æ˜åŒº
  574   1          int32_t gyro_fixed = 0;
  575   1          int32_t coeff_fixed = 0;   // ç³»æ•° = FX_SCALE / é‡ç¨‹è½¬æ¢å› å­
  576   1      
  577   1          switch(IMU963RA_GYR_SAMPLE)
  578   1          {
  579   2              case 0x52:    // Â±125 dps, ç³»æ•° 228.6
  580   2                  coeff_fixed = FIXED_DIV(FX_SCALE, 229);   // è¿‘ä¼¼ 1000/228.6 â‰ˆ 4.37 -> 4 (æ”¾å¤§åè¯¯å·®
             -å¯æ¥å—)
  581   2                  break;
  582   2              case 0x50:    // Â±250 dps, ç³»æ•° 114.3
  583   2                  coeff_fixed = FIXED_DIV(FX_SCALE, 114);   // â‰ˆ8.77 -> 9
  584   2                  break;
  585   2              case 0x54:    // Â±500 dps, ç³»æ•° 57.1
  586   2                  coeff_fixed = FIXED_DIV(FX_SCALE, 57);    // â‰ˆ17.54 -> 18
  587   2                  break;
  588   2              case 0x58:    // Â±1000 dps, ç³»æ•° 28.6
  589   2                  coeff_fixed = FIXED_DIV(FX_SCALE, 29);    // â‰ˆ34.5 -> 34
  590   2                  break;
  591   2              case 0x5C:    // Â±2000 dps, ç³»æ•° 14.3
  592   2                  coeff_fixed = 70;    // 1000 / 14.3 â‰ˆ 70
  593   2                  break;
  594   2              case 0x51:    // Â±4000 dps, ç³»æ•° 7.1
  595   2                  coeff_fixed = FIXED_DIV(FX_SCALE, 7);     // â‰ˆ142.8 -> 143
  596   2                  break;
  597   2              default:
  598   2                  coeff_fixed = 0;
  599   2                  break;
  600   2          }
  601   1      
  602   1          gyro_fixed = gyro_value * coeff_fixed;   
  603   1      
  604   1          return gyro_fixed;
  605   1      }
  606          
  607          //-------------------------------------------------------------------------------------------------------
             -------------
  608          /**
  609           * @brief  é™€èºä»ªé›¶åæ ¡å‡†
  610           * @param  samples  é‡‡æ ·æ¬¡æ•° (å»ºè®® â‰¥ 200)
  611           */
  612          //-------------------------------------------------------------------------------------------------------
             -------------
  613          void gyro_zero_calibration(uint16_t samples)
  614          {
  615   1          // å˜é‡å£°æ˜åŒº
  616   1          uint16_t i = 0;
  617   1          int32_t  sum = 0;
  618   1          int32_t  sample_fixed = 0;
  619   1      
  620   1          if (samples == 0)
  621   1          {
C251 COMPILER V5.60.0,  SEEKFREE_IMU963RA                                                  14/07/25  14:27:43  PAGE 12  

  622   2              return;
  623   2          }
  624   1      
  625   1          for (i = 0; i < samples; i++)
  626   1          {
  627   2              imu963ra_get_gyro();
  628   2              sample_fixed = imu963ra_gyro_transition_fixed(imu963ra_gyro_z);
  629   2              sum += sample_fixed;
  630   2              delay_ms(2);
  631   2          }
  632   1      
  633   1          gyro_z_offset_fixed = (int32_t)(sum / samples);
  634   1      }
  635          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2411     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       133     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        72     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
