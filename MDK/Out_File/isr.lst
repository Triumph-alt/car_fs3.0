C251 COMPILER V5.60.0,  isr                                                                15/07/25  15:45:25  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE isr
OBJECT MODULE PLACED IN .\Out_File\isr.obj
COMPILER INVOKED BY: D:\Software\Keil5\c251v560\C251\BIN\C251.EXE ..\USER\src\isr.c LARGE INTR2 WARNINGLEVEL(3) OPTIMIZE
                    -(0,SPEED) BROWSE INCDIR(..\USER\inc;..\USER\src;..\libraries;..\seekfree_libraries;..\seekfree_peripheral) DEBUG PRINT(.
                    -\Out_File\isr.lst) OBJECT(.\Out_File\isr.obj) 

stmt  level    source

    1          ///******************************************************************************************************
             -***************
    2          // * COPYRIGHT NOTICE
    3          // * Copyright (c) 2020,ÈÄêÈ£ûÁßëÊäÄ
    4          // * All rights reserved.
    5          // * ÊäÄÊúØËÆ®ËÆ∫QQÁæ§Ôºö‰∏ÄÁæ§Ôºö179029047(Â∑≤Êª°)  ‰∫åÁæ§Ôºö244861897(Â∑≤Êª°)  ‰∏âÁæ§Ôºö824575535
    6          // *
    7          // * ‰ª•‰∏ãÊâÄÊúâÂÜÖÂÆπÁâàÊùÉÂùáÂ±ûÈÄêÈ£ûÁßëÊäÄÊâÄÊúâÔºåÊú™ÁªèÂÖÅËÆ∏‰∏çÂæóÁî®‰∫éÂïÜ‰∏öÁî®ÈÄîÔºå
    8          // * Ê¨¢ËøéÂêÑ‰Ωç‰ΩøÁî®Âπ∂‰º†Êí≠Êú¨Á®ãÂ∫èÔºå‰øÆÊîπÂÜÖÂÆπÊó∂ÂøÖÈ°ª‰øùÁïôÈÄêÈ£ûÁßëÊäÄÁöÑÁâàÊùÉÂ£∞Êòé„ÄÇ
    9          // *
   10          // * @file                      isr
   11          // * @company                   ÊàêÈÉΩÈÄêÈ£ûÁßëÊäÄÊúâÈôêÂÖ¨Âè∏
   12          // * @author                    ÈÄêÈ£ûÁßëÊäÄ(QQ790875685)
   13          // * @version                   Êü•ÁúãdocÂÜÖversionÊñá‰ª∂ ÁâàÊú¨ËØ¥Êòé
   14          // * @Software                  MDK FOR C251 V5.60
   15          // * @Target core               STC32G12K128
   16          // * @Taobao                    https://seekfree.taobao.com/
   17          // * @date                      2020-4-14
   18          // ******************************************************************************************************
             -**************/
   19          #include "headfile.h"
   20          #include "zf_nvic.h"
   21          // #include "zf_exti.h"
   22          #include "zf_uart.h"
   23          #include "zf_tim.h"
   24          
   25          int g_encoder_average = 0;                       //Â∑¶Âè≥ÁºñÁ†ÅÂô®ÁöÑÂπ≥ÂùáÂÄº
   26          float Gyro_Z = 0, filtered_GyroZ = 0;            // ÈôÄËû∫‰ª™ËßíÈÄüÂ∫¶ÁöÑÂéüÂßãÂÄºÂíåÂç°Â∞îÊõºÊª§Ê≥¢‰πãÂê
             -éÁöÑÂÄº
   27          int32_t g_DutyLeft = 0, g_DutyRight = 0;         // ÊúÄÂêéÁúüÊ≠£Ë¶ÅÁªôÁîµÊú∫ÁöÑPWMÂÄº
   28          
   29          //pidÊéßÂà∂Áõ∏ÂÖ≥ÂèòÈáè
   30          float speed_pid = 0, turn_pid = 0;               //ÈÄüÂ∫¶ÁéØÂíåËΩ¨ÂêëÁéØpidÁöÑÂÄº
   31          int g_speedpoint = 50;
   32          int g_leftpoint = 0, g_rightpoint = 0;           //Â∑¶Âè≥ËΩÆÁöÑÁõÆÊ†áÈÄüÂ∫¶
   33          int16_t positionReal = 0; 
   34          
   35          // ËúÇÈ∏£Âô®ÊéßÂà∂Áõ∏ÂÖ≥ÂèòÈáè
   36          uint8_t beep_flag = 0;                           // ËúÇÈ∏£Âô®ÂºÄÂêØÊ†áÂøóÔºå1Ë°®Á§∫ÂºÄÂêØ
   37          uint16_t beep_count = 0;                         // ËúÇÈ∏£Âô®ËÆ°Êó∂ËÆ°Êï∞Âô®
   38          uint8_t track_ten_cnt = 0;                       //Âá∫ÂÖ•ÁéØÈáçÂ§çÂà§ÂÆöËÆ°Êó∂Âô®
   39          uint16_t outisland_cnt = 0;                       //Âá∫ÂÖ•ÁéØÂ≤õÈáçÂ§çÂà§ÂÆöËÆ°Êó∂Âô®
   40          
   41          volatile uint8_t r_position = 30;
   42          volatile uint16_t r_distance = 7400;
   43          volatile uint16_t s_distance = 5500;
   44          
   45          int count = 0, flag = 0;
   46          
   47          //UART1‰∏≠Êñ≠
   48          void UART1_Isr() interrupt 4
   49          {
   50   1      //  uint8 res;
   51   1      //      static uint8 dwon_count;
   52   1              
   53   1          if(UART1_GET_TX_FLAG)
   54   1          {
C251 COMPILER V5.60.0,  isr                                                                15/07/25  15:45:25  PAGE 2   

   55   2              UART1_CLEAR_TX_FLAG;
   56   2              busy[1] = 0;
   57   2          }
   58   1              
   59   1          if(UART1_GET_RX_FLAG)
   60   1          {
   61   2              UART1_CLEAR_RX_FLAG;
   62   2      //        res = SBUF;
   63   2      //        //Á®ãÂ∫èËá™Âä®‰∏ãËΩΩ
   64   2      //        if(res == 0x7F)
   65   2      //        {
   66   2      //            if(dwon_count++ > 20)
   67   2      //                IAP_CONTR = 0x60;
   68   2      //        }
   69   2      //        else
   70   2      //        {
   71   2      //            dwon_count = 0;
   72   2      //        }
   73   2          }
   74   1      }
   75          
   76          //UART2‰∏≠Êñ≠
   77          void UART2_Isr() interrupt 8
   78          {
   79   1          if(UART2_GET_TX_FLAG)
   80   1              {
   81   2              UART2_CLEAR_TX_FLAG;
   82   2                      busy[2] = 0;
   83   2              }
   84   1          if(UART2_GET_RX_FLAG)
   85   1              {
   86   2              UART2_CLEAR_RX_FLAG;
   87   2                      
   88   2                      //Êé•Êî∂Êï∞ÊçÆÂØÑÂ≠òÂô®‰∏∫ÔºöS2BUF
   89   2      
   90   2              }
   91   1      }
   92          
   93          
   94          //UART3‰∏≠Êñ≠
   95          void UART3_Isr() interrupt 17
   96          {
   97   1          if(UART3_GET_TX_FLAG)
   98   1              {
   99   2              UART3_CLEAR_TX_FLAG;
  100   2                      busy[3] = 0;
  101   2              }
  102   1          if(UART3_GET_RX_FLAG)
  103   1              {
  104   2              UART3_CLEAR_RX_FLAG;
  105   2                      
  106   2                      //Êé•Êî∂Êï∞ÊçÆÂØÑÂ≠òÂô®‰∏∫ÔºöS3BUF
  107   2      
  108   2              }
  109   1      }
  110          
  111          
  112          //UART4‰∏≠Êñ≠
  113          void UART4_Isr() interrupt 18
  114          {
  115   1          if(UART4_GET_TX_FLAG)
  116   1              {
  117   2              UART4_CLEAR_TX_FLAG;
  118   2                      busy[4] = 0;
  119   2              }
  120   1          if(UART4_GET_RX_FLAG)
C251 COMPILER V5.60.0,  isr                                                                15/07/25  15:45:25  PAGE 3   

  121   1              {
  122   2              UART4_CLEAR_RX_FLAG;
  123   2                      
  124   2                      //Êé•Êî∂Êï∞ÊçÆÂØÑÂ≠òÂô®‰∏∫ÔºöS4BUF;
  125   2                      g_rxdat = S4BUF;
  126   2                      g_rxbuffer[g_rxpointer++] = g_rxdat;
  127   2              }
  128   1      }
  129          
  130          void INT0_Isr() interrupt 0
  131          {
  132   1              
  133   1      }
  134          
  135          
  136          void INT1_Isr() interrupt 2
  137          {
  138   1      
  139   1      }
  140          
  141          
  142          // void INT2_Isr() interrupt 10
  143          // {
  144          //      INT2_CLEAR_FLAG;  //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  145          // }
  146          
  147          
  148          // void INT3_Isr() interrupt 11
  149          // {
  150          //      INT3_CLEAR_FLAG;  //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  151          // }
  152          
  153          // void INT4_Isr() interrupt 16
  154          // {
  155          //      INT4_CLEAR_FLAG;  //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  156          // }
  157          
  158          void TM0_Isr() interrupt 1
  159          {
  160   1      
  161   1      }
  162          
  163          
  164          /* 10ms */
  165          void TM1_Isr() interrupt 3
  166          {
  167   1              int i = 0;
  168   1              
  169   1              key[0].state = P72;
  170   1              key[1].state = P71;
  171   1              key[2].state = P70;
  172   1              key[3].state = P73;
  173   1              
  174   1              for (i = 0; i < 4; i++)
  175   1              {
  176   2                      switch (key[i].step)
  177   2                      {
  178   3                              case 0:
  179   3                              {
  180   4                                      if (key[i].state == 0)
  181   4                                      {
  182   5                                              key[i].step = 1;
  183   5                                      }
  184   4                              }
  185   3                              break;
  186   3                              
C251 COMPILER V5.60.0,  isr                                                                15/07/25  15:45:25  PAGE 4   

  187   3                              case 1:
  188   3                              {
  189   4                                      if (key[i].state == 0)
  190   4                                      {
  191   5                                              key[i].step = 2;
  192   5                                              key[i].flag = 1;
  193   5                                      }
  194   4                                      else
  195   4                                      {
  196   5                                              key[i].step = 0;
  197   5                                      }
  198   4                              }
  199   3                              break;
  200   3                              
  201   3                              case 2:
  202   3                              {
  203   4                                      if (key[i].state == 1)
  204   4                                      {
  205   5                                              key[i].step = 0;
  206   5                                      }
  207   4                              }
  208   3                              break;
  209   3                      }
  210   2              }
  211   1              
  212   1              /* ÊôÆÈÄöÂÆöÊó∂ÂäüËÉΩÔºåÂ§áÁî® */
  213   1              count++;
  214   1              if (count >= 50)
  215   1              {
  216   2                      flag = 1;
  217   2                      count = 0;
  218   2              }
  219   1      
  220   1              /* Ê£ÄÊµãËµõÈÅìÁ±ªÂûãÂèòÂåñÂπ∂ÊéßÂà∂ËúÇÈ∏£Âô® */
  221   1          if (track_type != track_type_last)
  222   1          {
  223   2              // ËµõÈÅìÁ±ªÂûãÂèëÁîüÂèòÂåñÔºåÂêØÂä®ËúÇÈ∏£Âô®
  224   2              beep_flag = 1;
  225   2              beep_count = 0;  // ÈáçÁΩÆËÆ°Êï∞Âô®
  226   2                      P26 = 0;         // ÊâìÂºÄËúÇÈ∏£Âô®
  227   2              
  228   2              // Êõ¥Êñ∞‰∏ä‰∏ÄÊ¨°ËµõÈÅìÁ±ªÂûã
  229   2              track_type_last = track_type;
  230   2          }
  231   1          
  232   1          /* ËúÇÈ∏£Âô®ËÆ°Êó∂ÊéßÂà∂ */
  233   1          if (beep_flag)
  234   1          {
  235   2              beep_count++;
  236   2              // 10ms * 20 = 200ms
  237   2              if (beep_count >= 10)
  238   2              {
  239   3                  beep_count = 0;
  240   3                  beep_flag = 0;
  241   3                  P26 = 1;  // ÂÖ≥Èó≠ËúÇÈ∏£Âô®
  242   3              }
  243   2          }
  244   1      
  245   1              /* Âá∫ÁéØËæÖÂä©Âà§ÂÆöÔºåÂ§áÁî® */
  246   1          // if (track_route_status == 3)
  247   1          // {
  248   1              //      P26 = 0;
  249   1          //     beep_count++;
  250   1          //     // 10ms * 20 = 200ms
  251   1          //     if (beep_count >= 10)
  252   1          //     {
C251 COMPILER V5.60.0,  isr                                                                15/07/25  15:45:25  PAGE 5   

  253   1          //         beep_count = 0;
  254   1          //         P26 = 1;  // ÂÖ≥Èó≠ËúÇÈ∏£Âô®
  255   1              //              track_route_status = 2;
  256   1          //     }
  257   1          // }
  258   1      
  259   1              /* Âá∫ÂÖ•ÂçÅÂ≠óÂúÜÁéØËÆ°Êó∂Âà§ÂÆö */
  260   1              // if (ten_ch_flag == 1)
  261   1              // {
  262   1              //      track_ten_cnt++;
  263   1              //      if (track_ten_cnt >= 150)
  264   1              //      {
  265   1              //              track_ten_flag = 1;
  266   1              //              track_ten_cnt = 0;
  267   1              //              ten_ch_flag = 0;
  268   1              //      }
  269   1              // }
  270   1      
  271   1              /* Âá∫ÂÖ•ÁéØÂ≤õËÆ°Êó∂Âà§ÂÆö */
  272   1              if (island_ch_flag == 1)
  273   1              {
  274   2                      outisland_cnt++;
  275   2                      if (outisland_cnt >= 500)
  276   2                      {
  277   3                              track_island_flag = 1;
  278   3                              outisland_cnt = 0;
  279   3                              island_ch_flag = 0;
  280   3                      }
  281   2              }
  282   1      
  283   1      }
  284          
  285          
  286          void TM2_Isr() interrupt 12
  287          {
  288   1              TIM2_CLEAR_FLAG;  //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  289   1              
  290   1              if (startKeyFlag == 1)
  291   1              {
  292   2                      /* ÂàùÊ≠•ËØªÂèñÂπ∂Ê∏ÖÈô§ÁºñÁ†ÅÂô®ÁöÑÂÄº */
  293   2                      EncoderL.encoder_original = get_left_encoder();
  294   2                      EncoderR.encoder_original = get_right_encoder();
  295   2      
  296   2                      /* ÂØπÁºñÁ†ÅÂô®ÁöÑÂÄºËøõË°åÊª§Ê≥¢ */
  297   2                      EncoderL.encoder_final = lowpass_filter(&leftSpeedFilt, EncoderL.encoder_original);
  298   2                      EncoderR.encoder_final = lowpass_filter(&rightSpeedFilt, EncoderR.encoder_original);
  299   2      
  300   2                      /* ÂØπÁºñÁ†ÅÂô®ÁöÑÂÄºËøõË°åÂºÇÂ∏∏Ê∂àÈô§ */
  301   2                      EncoderL.encoder_final = encoder_debounce(&EncoderDeboL, EncoderL.encoder_final);
  302   2                      EncoderR.encoder_final = encoder_debounce(&EncoderDeboR, EncoderR.encoder_final);
  303   2      
  304   2                      /* ÂèñÂ∑¶Âè≥ÁºñÁ†ÅÂô®Âπ≥ÂùáÂÄº */
  305   2                      g_encoder_average = (EncoderL.encoder_final + EncoderR.encoder_final) / 2;
  306   2      
  307   2                      /* ËØªÂèñÈôÄËû∫‰ª™ÂéüÂßãÊï∞ÊçÆÂπ∂Â∞ÜÂÖ∂ËΩ¨Âåñ‰∏∫Áâ©ÁêÜÊï∞ÊçÆ */
  308   2                      imu963ra_get_gyro();
  309   2                      Gyro_Z = imu963ra_gyro_transition(imu963ra_gyro_z);
  310   2      
  311   2                      /* ÂØπGyro_ZËøõË°åÂç°Â∞îÊõºÊª§Ê≥¢ */
  312   2                      filtered_GyroZ = kalman_update(&imu693_kf, Gyro_Z);
  313   2                      
  314   2                      if (track_type == 0)//ÊôÆÈÄöÁõ¥Á∫ø
  315   2                      {               
  316   3                              positionReal = position;
  317   3                      }
  318   2                      else if (track_type == 1)//Áõ¥Ëßí
C251 COMPILER V5.60.0,  isr                                                                15/07/25  15:45:25  PAGE 6   

  319   2                      {               
  320   3                              positionReal = position;
  321   3                      }
  322   2                      else if (track_type == 3 && track_route_status == 1)//ÂúÜÁéØÂÖ•ÁéØ
  323   2                      {
  324   3                              g_intencoderALL += g_encoder_average;
  325   3                              
  326   3                              if(g_intencoderALL <= 10500)//Á¨¨‰∏ÄÈò∂ÊÆµÂÖàÁõ¥Ë°å
  327   3                              {
  328   4                                      positionReal = 0;
  329   4                              }
  330   3                              else//ËøõÂÖ•Á¨¨‰∫åÈò∂ÊÆµÊâìÊ≠ªËøõÁéØ
  331   3                              {
  332   4                                      if (track_route == 1)//Â∑¶ÁéØ
  333   4                                      {
  334   5                                              positionReal = 65;
  335   5                                      }
  336   4                                      else if (track_route == 2)//Âè≥ÁéØ
  337   4                                      {
  338   5                                              positionReal = -65;
  339   5                                      }
  340   4                                                              
  341   4                                      if (g_intencoderALL >= 11500)//ÂÖ•ÁéØÂÆåÊØï
  342   4                                      {
  343   5                                              track_route_status = 2;
  344   5                                              g_intencoderALL = 0;
  345   5                                      }
  346   4                              }
  347   3                      }
  348   2                      else if (track_type == 3 && track_route_status == 2)//ÁéØÂ≤õÂÜÖÈÉ®
  349   2                      {
  350   3                              positionReal = position;
  351   3      
  352   3                              g_intencoderALL += g_encoder_average;
  353   3      
  354   3                              if (g_intencoderALL >= 28000)
  355   3                              {
  356   4                                      g_intencoderALL = 0;
  357   4                              }
  358   3                      }
  359   2                      else if (track_type == 3 && track_route_status == 3)//ÂúÜÁéØÂá∫ÁéØ
  360   2                      {
  361   3                              g_intencoderALL += g_encoder_average;
  362   3                              
  363   3                              if (g_intencoderALL <= s_distance)//Á¨¨‰∏ÄÈò∂ÊÆµÊâìÊ≠ªÂá∫ÁéØ
  364   3                              {
  365   4                                      if (track_route == 1)//Â∑¶ÁéØ
  366   4                                      {
  367   5                                              positionReal = r_position;
  368   5                                      }
  369   4                                      else if (track_route == 2)//Âè≥ÁéØ
  370   4                                      {
  371   5                                              positionReal = -r_position;
  372   5                                      }
  373   4                              }
  374   3                              else//Á¨¨‰∫åÈò∂ÊÆµÁõ¥Ëµ∞
  375   3                              {
  376   4      //                              P26 = 1;
  377   4                                      positionReal = 0;
  378   4                                      
  379   4                                      if (g_intencoderALL >= r_distance)//Âá∫ÁéØÂÆåÊØï
  380   4                                      {
  381   5                                              track_type = 0;
  382   5                                              track_route = 0;
  383   5                                              track_route_status = 0;
  384   5                                              
C251 COMPILER V5.60.0,  isr                                                                15/07/25  15:45:25  PAGE 7   

  385   5                                              g_intencoderALL = 0;
  386   5                                      }
  387   4                              }
  388   3                      }
  389   2                      
  390   2                      /* ËΩ¨ÂêëÁéØPIDÊéßÂà∂ */
  391   2                      turn_pid = pid_poisitional_turnning(&TurnPID, positionReal, filtered_GyroZ);
  392   2      
  393   2                      /* Êõ¥Êñ∞Âç°Â∞îÊõºÊª§Ê≥¢Âô®ÁöÑÂÄº */
  394   2                      kalman_predict(&imu693_kf, turn_pid);
  395   2      
  396   2                      /* ÈÄüÂ∫¶ÁéØPIDÊéßÂà∂ */
  397   2                      speed_pid = pid_increment(&SpeedPID, g_encoder_average, g_speedpoint);
  398   2      
  399   2                      /* ÊéßÂà∂ÁîµÊú∫ */
  400   2                      g_DutyLeft = (int32_t)(speed_pid - turn_pid);
  401   2                      g_DutyRight = (int32_t)(speed_pid + turn_pid);
  402   2      
  403   2                      if (protection_flag == 1)
  404   2                      {
  405   3                              pid_clean(&SpeedPID);  // Ê∏ÖÈô§ÈÄüÂ∫¶ÁéØPID
  406   3                              pid_clean(&TurnPID);   // Ê∏ÖÈô§ËΩ¨ÂêëÁéØPID
  407   3      
  408   3                              set_motor_pwm(0, 0);
  409   3                      }
  410   2                      else
  411   2                      {
  412   3                              set_motor_pwm(g_DutyLeft, g_DutyRight);
  413   3                      }
  414   2              }
  415   1      }
  416          
  417          
  418          void TM3_Isr() interrupt 19
  419          {
  420   1              TIM3_CLEAR_FLAG; //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  421   1              
  422   1      }
  423          
  424          void TM4_Isr() interrupt 20
  425          {
  426   1              TIM4_CLEAR_FLAG; //Ê∏ÖÈô§‰∏≠Êñ≠Ê†áÂøó
  427   1      
  428   1      }
  429          
  430          //void  INT0_Isr()  interrupt 0;
  431          //void  TM0_Isr()   interrupt 1;
  432          //void  INT1_Isr()  interrupt 2;
  433          //void  TM1_Isr()   interrupt 3;
  434          //void  UART1_Isr() interrupt 4;
  435          //void  ADC_Isr()   interrupt 5;
  436          //void  LVD_Isr()   interrupt 6;
  437          //void  PCA_Isr()   interrupt 7;
  438          //void  UART2_Isr() interrupt 8;
  439          //void  SPI_Isr()   interrupt 9;
  440          //void  INT2_Isr()  interrupt 10;
  441          //void  INT3_Isr()  interrupt 11;
  442          //void  TM2_Isr()   interrupt 12;
  443          //void  INT4_Isr()  interrupt 16;
  444          //void  UART3_Isr() interrupt 17;
  445          //void  UART4_Isr() interrupt 18;
  446          //void  TM3_Isr()   interrupt 19;
  447          //void  TM4_Isr()   interrupt 20;
  448          //void  CMP_Isr()   interrupt 21;
  449          //void  I2C_Isr()   interrupt 24;
  450          //void  USB_Isr()   interrupt 25;
C251 COMPILER V5.60.0,  isr                                                                15/07/25  15:45:25  PAGE 8   

  451          //void  PWM1_Isr()  interrupt 26;
  452          //void  PWM2_Isr()  interrupt 27;


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1770     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        51     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       149     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
