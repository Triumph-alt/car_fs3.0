C251 COMPILER V5.60.0,  isr                                                                14/07/25  14:46:32  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE isr
OBJECT MODULE PLACED IN .\Out_File\isr.obj
COMPILER INVOKED BY: D:\Software\Keil5\c251v560\C251\BIN\C251.EXE ..\USER\src\isr.c LARGE INTR2 WARNINGLEVEL(3) OPTIMIZE
                    -(0,SPEED) BROWSE INCDIR(..\USER\inc;..\USER\src;..\libraries;..\seekfree_libraries;..\seekfree_peripheral) DEBUG PRINT(.
                    -\Out_File\isr.lst) OBJECT(.\Out_File\isr.obj) 

stmt  level    source

    1          ///******************************************************************************************************
             -***************
    2          // * COPYRIGHT NOTICE
    3          // * Copyright (c) 2020,逐飞科技
    4          // * All rights reserved.
    5          // * 技术讨论QQ群：一群：179029047(已满)  二群：244861897(已满)  三群：824575535
    6          // *
    7          // * 以下所有内容版权均属逐飞科技所有，未经允许不得用于商业用途，
    8          // * 欢迎各位使用并传播本程序，修改内容时必须保留逐飞科技的版权声明。
    9          // *
   10          // * @file                      isr
   11          // * @company                   成都逐飞科技有限公司
   12          // * @author                    逐飞科技(QQ790875685)
   13          // * @version                   查看doc内version文件 版本说明
   14          // * @Software                  MDK FOR C251 V5.60
   15          // * @Target core               STC32G12K128
   16          // * @Taobao                    https://seekfree.taobao.com/
   17          // * @date                      2020-4-14
   18          // ******************************************************************************************************
             -**************/
   19          #include "headfile.h"
   20          #include "zf_nvic.h"
   21          // #include "zf_exti.h"
   22          #include "zf_uart.h"
   23          #include "zf_tim.h"
   24          #include "fixed_point.h"
   25          #include "SEEKFREE_IMU963RA.h"   // 陀螺仪接口及零偏校准 extern
   26          
   27          extern volatile int32_t gyro_z_offset_fixed;
   28          
   29          int g_encoder_average = 0;                       //左右编码器的平均值
   30          int32_t Gyro_Z_fixed = 0;                        // 定点数角速度(°/s * FX_SCALE)
   31          int32_t g_DutyLeft = 0, g_DutyRight = 0;         // 最后真正要给电机的PWM值
   32          
   33          //pid控制相关变量
   34          int32_t speed_pid = 0, turn_pid = 0;               // 定点数PID输出值 (°/s * FX_SCALE 或 PWM)
   35          int g_speedpoint = 100;
   36          int g_leftpoint = 0, g_rightpoint = 0;           //左右轮的目标速度
   37          
   38          // 蜂鸣器控制相关变量
   39          uint8_t beep_flag = 0;                           // 蜂鸣器开启标志，1表示开启
   40          uint16_t beep_count = 0;                         // 蜂鸣器计时计数器
   41          uint8_t track_ten_cnt = 0;                       //出入环重复判定计时器
   42          
   43          int count = 0, flag = 0;
   44          
   45          //UART1中断
   46          void UART1_Isr() interrupt 4
   47          {
   48   1      //  uint8 res;
   49   1      //      static uint8 dwon_count;
   50   1              
   51   1          if(UART1_GET_TX_FLAG)
   52   1          {
   53   2              UART1_CLEAR_TX_FLAG;
   54   2              busy[1] = 0;
   55   2          }
C251 COMPILER V5.60.0,  isr                                                                14/07/25  14:46:32  PAGE 2   

   56   1              
   57   1          if(UART1_GET_RX_FLAG)
   58   1          {
   59   2              UART1_CLEAR_RX_FLAG;
   60   2      //        res = SBUF;
   61   2      //        //程序自动下载
   62   2      //        if(res == 0x7F)
   63   2      //        {
   64   2      //            if(dwon_count++ > 20)
   65   2      //                IAP_CONTR = 0x60;
   66   2      //        }
   67   2      //        else
   68   2      //        {
   69   2      //            dwon_count = 0;
   70   2      //        }
   71   2          }
   72   1      }
   73          
   74          //UART2中断
   75          void UART2_Isr() interrupt 8
   76          {
   77   1          if(UART2_GET_TX_FLAG)
   78   1              {
   79   2              UART2_CLEAR_TX_FLAG;
   80   2                      busy[2] = 0;
   81   2              }
   82   1          if(UART2_GET_RX_FLAG)
   83   1              {
   84   2              UART2_CLEAR_RX_FLAG;
   85   2                      
   86   2                      //接收数据寄存器为：S2BUF
   87   2      
   88   2              }
   89   1      }
   90          
   91          
   92          //UART3中断
   93          void UART3_Isr() interrupt 17
   94          {
   95   1          if(UART3_GET_TX_FLAG)
   96   1              {
   97   2              UART3_CLEAR_TX_FLAG;
   98   2                      busy[3] = 0;
   99   2              }
  100   1          if(UART3_GET_RX_FLAG)
  101   1              {
  102   2              UART3_CLEAR_RX_FLAG;
  103   2                      
  104   2                      //接收数据寄存器为：S3BUF
  105   2      
  106   2              }
  107   1      }
  108          
  109          
  110          //UART4中断
  111          void UART4_Isr() interrupt 18
  112          {
  113   1          if(UART4_GET_TX_FLAG)
  114   1              {
  115   2              UART4_CLEAR_TX_FLAG;
  116   2                      busy[4] = 0;
  117   2              }
  118   1          if(UART4_GET_RX_FLAG)
  119   1              {
  120   2              UART4_CLEAR_RX_FLAG;
  121   2                      
C251 COMPILER V5.60.0,  isr                                                                14/07/25  14:46:32  PAGE 3   

  122   2                      //接收数据寄存器为：S4BUF;
  123   2                      g_rxdat = S4BUF;
  124   2                      g_rxbuffer[g_rxpointer++] = g_rxdat;
  125   2              }
  126   1      }
  127          
  128          void INT0_Isr() interrupt 0
  129          {
  130   1              
  131   1      }
  132          
  133          
  134          void INT1_Isr() interrupt 2
  135          {
  136   1      
  137   1      }
  138          
  139          
  140          // void INT2_Isr() interrupt 10
  141          // {
  142          //      INT2_CLEAR_FLAG;  //清除中断标志
  143          // }
  144          
  145          
  146          // void INT3_Isr() interrupt 11
  147          // {
  148          //      INT3_CLEAR_FLAG;  //清除中断标志
  149          // }
  150          
  151          // void INT4_Isr() interrupt 16
  152          // {
  153          //      INT4_CLEAR_FLAG;  //清除中断标志
  154          // }
  155          
  156          void TM0_Isr() interrupt 1
  157          {
  158   1      
  159   1      }
  160          
  161          
  162          void TM1_Isr() interrupt 3
  163          {
  164   1              int i = 0;
  165   1              
  166   1              key[0].state = P72;
  167   1              key[1].state = P71;
  168   1              key[2].state = P70;
  169   1              key[3].state = P73;
  170   1              
  171   1              for (i = 0; i < 4; i++)
  172   1              {
  173   2                      switch (key[i].step)
  174   2                      {
  175   3                              case 0:
  176   3                              {
  177   4                                      if (key[i].state == 0)
  178   4                                      {
  179   5                                              key[i].step = 1;
  180   5                                      }
  181   4                              }
  182   3                              break;
  183   3                              
  184   3                              case 1:
  185   3                              {
  186   4                                      if (key[i].state == 0)
  187   4                                      {
C251 COMPILER V5.60.0,  isr                                                                14/07/25  14:46:32  PAGE 4   

  188   5                                              key[i].step = 2;
  189   5                                              key[i].flag = 1;
  190   5                                      }
  191   4                                      else
  192   4                                      {
  193   5                                              key[i].step = 0;
  194   5                                      }
  195   4                              }
  196   3                              break;
  197   3                              
  198   3                              case 2:
  199   3                              {
  200   4                                      if (key[i].state == 1)
  201   4                                      {
  202   5                                              key[i].step = 0;
  203   5                                      }
  204   4                              }
  205   3                              break;
  206   3                      }
  207   2              }
  208   1              
  209   1              /* 普通定时功能，备用 */
  210   1              count++;
  211   1              if (count >= 50)
  212   1              {
  213   2                      flag = 1;
  214   2                      count = 0;
  215   2              }
  216   1      
  217   1              /* 检测赛道类型变化并控制蜂鸣器 */
  218   1          if (track_type != track_type_last)
  219   1          {
  220   2              // 赛道类型发生变化，启动蜂鸣器
  221   2              beep_flag = 1;
  222   2              beep_count = 0;  // 重置计数器
  223   2              P26 = 0;         // 打开蜂鸣器
  224   2              
  225   2              // 更新上一次赛道类型
  226   2              track_type_last = track_type;
  227   2          }
  228   1          
  229   1          /* 蜂鸣器计时控制 */
  230   1          if (beep_flag)
  231   1          {
  232   2              beep_count++;
  233   2              // 10ms * 20 = 200ms
  234   2              if (beep_count >= 10)
  235   2              {
  236   3                  beep_count = 0;
  237   3                  beep_flag = 0;
  238   3                  P26 = 1;  // 关闭蜂鸣器
  239   3              }
  240   2          }
  241   1      
  242   1              /* 出入十字圆环计时判定 */
  243   1              if (ten_change_flag == 1)
  244   1              {
  245   2                      track_ten_cnt++;
  246   2                      if (track_ten_cnt >= 150)
  247   2                      {
  248   3                              track_ten_flag = 1;
  249   3                              track_ten_cnt = 0;
  250   3                              ten_change_flag = 0;
  251   3                      }
  252   2              }
  253   1      }
C251 COMPILER V5.60.0,  isr                                                                14/07/25  14:46:32  PAGE 5   

  254          
  255          
  256          void TM2_Isr() interrupt 12
  257          {
  258   1              TIM2_CLEAR_FLAG;  //清除中断标志
  259   1              P26 = 0;
  260   1              
  261   1      //      if (startKeyFlag == 1)
  262   1      //      {
  263   1                      /* 初步读取并清除编码器的值 */
  264   1                      EncoderL.encoder_original = get_left_encoder();
  265   1                      EncoderR.encoder_original = get_right_encoder();
  266   1      
  267   1                      /* 对编码器的值进行定点低通滤波 */
  268   1                      EncoderL.encoder_final = encoder_lowpass_filter(&leftSpeedFilt, EncoderL.encoder_original);
  269   1                      EncoderR.encoder_final = encoder_lowpass_filter(&rightSpeedFilt, EncoderR.encoder_original);
  270   1      
  271   1                      /* 对编码器的值进行去毛刺处理 */
  272   1                      EncoderL.encoder_final = encoder_debounce(&EncoderDeboL, EncoderL.encoder_final);
  273   1                      EncoderR.encoder_final = encoder_debounce(&EncoderDeboR, EncoderR.encoder_final);
  274   1      
  275   1                      /* 取左右编码器平均值 */
  276   1                      g_encoder_average = (EncoderL.encoder_final + EncoderR.encoder_final) / 2;
  277   1      
  278   1                      /* 读取陀螺仪原始数据并转换为定点数 */
  279   1                      imu963ra_get_gyro();
  280   1                      Gyro_Z_fixed = imu963ra_gyro_transition_fixed(imu963ra_gyro_z);
  281   1              
  282   1              /* 零点漂移校正 */
  283   1              Gyro_Z_fixed -= gyro_z_offset_fixed;
  284   1      
  285   1                      /* 一阶低通滤波 (输入为定点数，输出仍为定点数) */
  286   1                      Gyro_Z_fixed = fixed_lowpass_filter(&gyro_z_filt, Gyro_Z_fixed);
  287   1      
  288   1                      /* 转向环PID控制 (将滤波后的定点数转回整数再传入) */
  289   1                      turn_pid = pid_positional_turning(&TurnPID, (int32_t)position, (int32_t)Gyro_Z_fixed / FX_SCALE);
  290   1      
  291   1                      /* 速度环PID控制 */
  292   1                      speed_pid = pid_increment(&SpeedPID, (int32_t)g_encoder_average, (int32_t)g_speedpoint);
  293   1      
  294   1                      /* 控制电机 (全定点数运算) */
  295   1                      g_DutyLeft = speed_pid - turn_pid;
  296   1                      g_DutyRight = speed_pid + turn_pid;
  297   1      
  298   1                      if (protection_flag == 1)
  299   1                      {
  300   2                              pid_clean(&SpeedPID);  // 清除速度环PID
  301   2                              pid_clean(&TurnPID);   // 清除转向环PID
  302   2      
  303   2                              set_motor_pwm(0, 0);
  304   2                      }
  305   1                      else
  306   1                      {
  307   2                              set_motor_pwm(g_DutyLeft, g_DutyRight);
  308   2                      }
  309   1      //      }
  310   1              
  311   1              P26 = 1;
  312   1      }
  313          
  314          
  315          void TM3_Isr() interrupt 19
  316          {
  317   1              TIM3_CLEAR_FLAG; //清除中断标志
  318   1              
  319   1      }
C251 COMPILER V5.60.0,  isr                                                                14/07/25  14:46:32  PAGE 6   

  320          
  321          void TM4_Isr() interrupt 20
  322          {
  323   1              TIM4_CLEAR_FLAG; //清除中断标志
  324   1      
  325   1      }
  326          
  327          //void  INT0_Isr()  interrupt 0;
  328          //void  TM0_Isr()   interrupt 1;
  329          //void  INT1_Isr()  interrupt 2;
  330          //void  TM1_Isr()   interrupt 3;
  331          //void  UART1_Isr() interrupt 4;
  332          //void  ADC_Isr()   interrupt 5;
  333          //void  LVD_Isr()   interrupt 6;
  334          //void  PCA_Isr()   interrupt 7;
  335          //void  UART2_Isr() interrupt 8;
  336          //void  SPI_Isr()   interrupt 9;
  337          //void  INT2_Isr()  interrupt 10;
  338          //void  INT3_Isr()  interrupt 11;
  339          //void  TM2_Isr()   interrupt 12;
  340          //void  INT4_Isr()  interrupt 16;
  341          //void  UART3_Isr() interrupt 17;
  342          //void  UART4_Isr() interrupt 18;
  343          //void  TM3_Isr()   interrupt 19;
  344          //void  TM4_Isr()   interrupt 20;
  345          //void  CMP_Isr()   interrupt 21;
  346          //void  I2C_Isr()   interrupt 24;
  347          //void  USB_Isr()   interrupt 25;
  348          //void  PWM1_Isr()  interrupt 26;
  349          //void  PWM2_Isr()  interrupt 27;


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1335     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        38     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       106     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
